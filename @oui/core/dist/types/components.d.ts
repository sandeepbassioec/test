/* eslint-disable */
/* tslint:disable */
/**
 * This is an autogenerated file created by the Stencil compiler.
 * It contains typing information for all components that exist in this project.
 */
import { HTMLStencilElement, JSXBase } from "./stencil-public-runtime";
import { IconName } from "@fortawesome/fontawesome-svg-core";
import { OMenuSelectPayload } from "./components/o-menu/o-menu";
import { OMenuItem } from "./components/o-menu-item/o-menu-item";
import { Element } from "./stencil-public-runtime";
import { OTabHidePayload, OTabShowPayload } from "./components/o-tab-group/o-tab-group";
export { IconName } from "@fortawesome/fontawesome-svg-core";
export { OMenuSelectPayload } from "./components/o-menu/o-menu";
export { OMenuItem } from "./components/o-menu-item/o-menu-item";
export { Element } from "./stencil-public-runtime";
export { OTabHidePayload, OTabShowPayload } from "./components/o-tab-group/o-tab-group";
export namespace Components {
    interface OAlert {
        /**
          * Hides the alert.
         */
        "hide": () => Promise<void>;
        /**
          * Indicates whether or not the alert is open.
         */
        "open": boolean;
        /**
          * Shows the alert.
         */
        "show": () => Promise<void>;
        /**
          * The variant of the alert.
         */
        "variant": 'primary' | 'success' | 'neutral' | 'warning' | 'danger';
    }
    interface OAppBar {
        /**
          * A description that gets read by assistive devices.
         */
        "label"?: string;
    }
    interface OAvatar {
        /**
          * Optional full name (first and last)
         */
        "initials"?: string;
        /**
          * Label for Accessability purposes
         */
        "label": string;
    }
    interface OBadge {
        /**
          * The color of the badge, can be "brand", "order", "payment", "shipping", "uncategorized"
         */
        "color": 'brand' | 'order' | 'payment' | 'shipping' | 'uncategorized';
        /**
          * @prop variant - The variant of the component, which determines its style.
          * @deprecated The prop 'variant' is deprecated as of v0.6.0
          * @see {@link http://oecui.oec.oeconnection.com/?path=/docs/components-badge--docs} OBadge Documentation
          * @since 0.1.0 - Initial introduction of variant prop
          * @since 0.6.0 - Variant prop deprecated
         */
        "variant": 'default' | 'order' | 'neutral' | 'shipping' | 'payment';
    }
    /**
     * OButton component supports different variants, colors, and states.
     * @component 
     * @since 0.1.0
     * @example ```html
     * <o-button variant="primary" color="brand">Click me</o-button>
     * ```
     */
    interface OButton {
        /**
          * The color theme of the button.
          * @prop color
          * @type {'brand' | 'buyer' | 'seller' | 'payment' | 'order' | 'shipping'}
          * @default 'brand'
          * @since 0.6.0
         */
        "color"?: 'brand' | 'buyer' | 'seller' | 'payment' | 'order' | 'shipping';
        /**
          * Indicates whether the button is disabled, preventing user interaction.
          * @prop disabled
          * @type {boolean}
          * @default false
          * @since 0.1.0
         */
        "disabled": boolean;
        /**
          * Indicates whether the button takes up the full width of the container.
          * @prop fullWidth
          * @type {boolean}
          * @default false
          * @since 0.2.0
         */
        "fullWidth": boolean;
        /**
          * Indicates whether the button is part of a button group.
          * @prop isButtonGroup
          * @type {boolean}
          * @default false
          * @since 0.1.0
         */
        "isButtonGroup"?: boolean;
        /**
          * Indicates whether the button is loading, preventing user interaction.
          * @prop loading
          * @type {boolean}
          * @default false
          * @since 0.3.0
         */
        "loading": boolean;
        /**
          * Programmatically focus the button element.
          * @method setFocus
          * @returns A promise that resolves when focus is set
          * @since 0.3.0
          * @example ```typescript const button = document.querySelector('o-button'); await button.setFocus(); ```
         */
        "setFocus": () => Promise<void>;
        /**
          * The type of the button.
          * @prop type
          * @type {'button' | 'submit' | 'reset'}
          * @default 'submit'
          * @since 0.4.0
         */
        "type": 'button' | 'submit' | 'reset';
        /**
          * The visual style variant of the OButton.
          * @prop variant
          * @type {'primary' | 'secondary' | 'text'}
          * @default 'primary'
          * @since 0.1.0
         */
        "variant"?: 'primary' | 'secondary' | 'text';
    }
    interface OButtonGroup {
    }
    interface OCallout {
    }
    interface OCard {
    }
    interface OCarousel {
        "goToSlide": (index: any) => Promise<void>;
        "navigation": boolean;
        "next": () => Promise<void>;
        "pagination": boolean;
        "previous": () => Promise<void>;
    }
    interface OCarouselItem {
    }
    interface OCheckbox {
        /**
          * Determines the initial checked state of the checkbox.
         */
        "checked": boolean;
        /**
          * @prop {boolean} disabled - Whether the input is disabled. Default is false.
         */
        "disabled": boolean;
        /**
          * @prop {string} errorText - The error message to display when validation fails.
         */
        "errorText": string;
        /**
          * @prop {boolean} indeterminate - Whether the checkbox is in an indeterminate state.
         */
        "indeterminate": boolean;
        /**
          * Used for Storybook documentation purposes.
         */
        "label": string;
        /**
          * @prop {string} nameValue - The name attribute for the checkbox. Default is 'default'.
         */
        "nameValue": string;
        /**
          * @prop {boolean} required - Indicates if the checkbox is required
         */
        "required": boolean;
        /**
          * @prop {string} value - The value of the checkbox input.
         */
        "value": string;
    }
    interface ODialog {
        /**
          * Public method to hide the dialog.
         */
        "hide": () => Promise<void>;
        /**
          * The label for the dialog header.
         */
        "label": string;
        /**
          * Determines whether the close button is shown.
         */
        "noClose": boolean;
        /**
          * Indicates whether or not the dialog is open.
         */
        "open": boolean;
        /**
          * Public method to show the dialog.
         */
        "show": () => Promise<void>;
    }
    interface ODivider {
        /**
          * Divider variant: 'horizontal' (default) or 'vertical'
         */
        "variant": 'horizontal' | 'vertical';
    }
    interface ODrawer {
        /**
          * Public method to hide the drawer.
         */
        "hide": () => Promise<void>;
        /**
          * The label for the aria label.
         */
        "label": string;
        /**
          * Determines whether the close button is shown.
         */
        "noClose": boolean;
        /**
          * Indicates whether or not the drawer is open.
         */
        "open": boolean;
        /**
          * Public method to show the drawer.
         */
        "show": () => Promise<void>;
    }
    interface ODropdown {
        "disabled": boolean;
        "open": boolean;
        "placement": | 'top'
		| 'top-start'
		| 'top-end'
		| 'bottom'
		| 'bottom-start'
		| 'bottom-end'
		| 'right'
		| 'right-start'
		| 'right-end'
		| 'left'
		| 'left-start'
		| 'left-end';
    }
    interface OFooter {
    }
    interface OIcon {
        /**
          * Optional color for the icon, can be a hex value or a color name.
         */
        "color"?: string;
        /**
          * The name of the icon to be rendered.
         */
        "name": IconName;
        /**
          * The size of the icon, can be 'sm', 'md', 'lg'.
         */
        "size": 'sm' | 'md' | 'lg';
    }
    interface OIconButton {
        /**
          * Optional color for the icon, can be a hex value or a color name.
         */
        "color"?: string;
        /**
          * Indicates whether the button is disabled, preventing user interaction.
         */
        "disabled"?: boolean;
        /**
          * A description that gets read by assistive devices.
         */
        "label"?: string;
        /**
          * The name of the icon to be rendered.
         */
        "name"?: IconName;
        /**
          * Public method to focus the button The name is setFocus() to avoid conflicts with the native focus() method
         */
        "setFocus": () => Promise<void>;
        /**
          * The size of the icon, can be 'sm', 'md', 'lg'.
         */
        "size": 'sm' | 'md' | 'lg';
        /**
          * The type of the button, can be "button", "submit", "reset".
         */
        "type": 'button' | 'submit' | 'reset';
    }
    interface OLabel {
        /**
          * The ID of the input element the label is associated with
         */
        "htmlFor"?: string;
        /**
          * The label text to display
         */
        "label": string;
        /**
          * Indicates if the field is required - shows asterisk
         */
        "required"?: boolean;
        /**
          * Variant for different label states
         */
        "variant"?: 'error' | 'disabled';
    }
    interface OList {
        "errorText": string;
        "helpText": string;
        "label": string;
        "name": string;
        "required": boolean;
        "setSelectedItem": (value: string) => Promise<boolean>;
        "showRadio": boolean;
        "value": string;
    }
    interface OListItem {
        "disabled": boolean;
        "name": string;
        "selected": boolean;
        "setFocus": (options?: FocusOptions) => Promise<void>;
        "setRadio": (show: boolean) => Promise<void>;
        "setSelected": (selected: boolean) => Promise<void>;
        "value": string;
    }
    interface OMenu {
        "getMenuItems": () => Promise<OMenuItem[]>;
        "setCurrentItem": (item: OMenuItem) => Promise<void>;
    }
    interface OMenuItem {
        "disabled": boolean;
        "index": 0 | -1;
        "setFocus": () => Promise<void>;
        "value": string;
    }
    interface OMenuLabel {
    }
    interface OOption {
        "current": boolean;
        "disabled": boolean;
        "getTextContent": () => Promise<string>;
        "selected": boolean;
        "value": string;
    }
    interface OPopup {
        /**
          * The open state of the popup, defaults to closed (false)
         */
        "active": boolean;
        /**
          * Sets whether an arrow displays along the bottom edge of the popup
         */
        "arrow": boolean;
        /**
          * Determines amount of space between anchor and popup content, defaults to zero
         */
        "distance": number;
        /**
          * Allows popup to change position on axis to remain in view, defaults to false
         */
        "flip": boolean;
        /**
          * Allows for creation of element between popup and anchor when popup is active to maintain hover state
         */
        "hoverBridge": boolean;
        /**
          * Position of the popup relative to the anchor
         */
        "placement": | 'top'
		| 'top-start'
		| 'top-end'
		| 'bottom'
		| 'bottom-start'
		| 'bottom-end'
		| 'right'
		| 'right-start'
		| 'right-end'
		| 'left'
		| 'left-start'
		| 'left-end';
        "reposition": () => Promise<void>;
        /**
          * Sets whether popup uses fixed positioning, defaults to absolute
         */
        "strategy": 'absolute' | 'fixed';
        /**
          * Syncs sizing of popup content to anchor sizing
         */
        "sync": 'width' | 'height' | 'both';
    }
    interface ORadio {
        /**
          * @prop {boolean} checked - Determines the initial checked state of the radio. Default is false.
         */
        "checked": boolean;
        /**
          * @prop {boolean} disabled - Whether the input is disabled. Default is false.
         */
        "disabled": boolean;
        /**
          * @prop {string} label - The label text for the radio input.
         */
        "label": string;
        /**
          * @prop {string} name - The name attribute for the radio input. Used to bind radios together in a radio group.
         */
        "name": string;
        /**
          * @prop {string} nameValue - The id attribute for the radio input.
         */
        "nameValue": string;
        /**
          * @prop {string} value - The value attribute for the radio input.
         */
        "value": string;
    }
    interface ORadioGroup {
        /**
          * @prop {string} errorText - The error message to display when validation fails.
         */
        "errorText": string;
        /**
          * @prop {string} helpText - The help text to display below the radio group.
         */
        "helpText": string;
        /**
          * @prop {string} label - The label text for the radio group.
         */
        "label": string;
        /**
          * @prop {string} name - The name attribute used to bind the child radios together.
         */
        "name": string;
        /**
          * @prop {boolean} required - Whether selection from the radio group is required. Default is false.
         */
        "required": boolean;
        /**
          * @prop {string} value - The value attribute for the radio group.
         */
        "value": string;
    }
    interface OSelect {
        "disabled": boolean;
        "errorText": string;
        "helpText": string;
        "hide": () => Promise<void>;
        "label": string;
        "nameValue": string;
        "open": boolean;
        "placeholder": string;
        "placement": 'top' | 'bottom';
        "required": boolean;
        "show": () => Promise<void>;
        "value"?: string;
    }
    interface OSidebar {
    }
    interface OSkeleton {
    }
    interface OStep {
        /**
          * Enables click interaction for the step
         */
        "clickable": boolean;
        /**
          * (Circle Number) Index of the step (starting from 1)
         */
        "index": number;
        /**
          * Position of the step within the stepper (internal)
         */
        "position": 'first' | 'last' | 'single' | 'inner';
        /**
          * Indicates whether the step is currently selected
         */
        "selected": boolean;
        /**
          * Visual variant of the step
         */
        "variant": 'completed' | 'active' | 'default' | 'error';
    }
    interface OStepper {
        /**
          * Enables click navigation on the steps
         */
        "clickable": boolean;
        /**
          * The index of the currently selected step
         */
        "selectedIndex": number;
        /**
          * Sets the selected step to the specified index
         */
        "setSelectedIndex": (index: number) => Promise<void>;
    }
    interface OTab {
        /**
          * Set to true to draw the tab in an active state.
         */
        "active": boolean;
        /**
          * Set to true to draw the tab in a disabled state.
         */
        "disabled": boolean;
        /**
          * The name of the tab panel the tab will control. The panel must be located in the same tab group.
         */
        "panel": string;
        /**
          * Removes focus from the tab.
         */
        "removeFocus": () => Promise<void>;
        /**
          * Sets focus to the tab.
         */
        "setFocus": (options?: FocusOptions) => Promise<void>;
    }
    interface OTabGroup {
        /**
          * Disables the scroll arrows that appear when tabs overflow.
         */
        "noScrollControls": boolean;
        /**
          * The placement of the tabs.
         */
        "placement": 'top';
        /**
          * Shows the specified tab panel.
         */
        "show": (panel: string) => Promise<void>;
    }
    interface OTabPanel {
        /**
          * When true, the tab panel will be shown.
         */
        "active": boolean;
        /**
          * The tab panel's name.
         */
        "name": string;
    }
    interface OTable {
    }
    interface OTag {
        /**
          * Determines if the tag is closable (shows a close button)
         */
        "closable": boolean;
        /**
          * Color variant of the tag
         */
        "color": 'brand' | 'order' | 'payment' | 'shipping' | 'uncategorized';
    }
    interface OTextarea {
        /**
          * @prop {boolean} disabled - Whether the textarea is disabled. Default is false.
         */
        "disabled": boolean;
        /**
          * @prop {string} errorText - The error message to display when validation fails.
         */
        "errorText": string;
        /**
          * @prop {string} helpText - The help text to display below the textarea.
         */
        "helpText": string;
        /**
          * @prop {string} label - The label text for the textarea.
         */
        "label": string;
        /**
          * @prop {string} nameValue - The name attribute for the input. Default is 'default'.
         */
        "nameValue": string;
        /**
          * @prop {string} placeholder - The placeholder text for the textarea.
         */
        "placeholder"?: string;
        /**
          * @prop {boolean} required - Whether the textarea is required. Default is false.
         */
        "required": boolean;
        /**
          * @prop {string} value - The current value of the textarea.
         */
        "value"?: string;
    }
    interface OTextfield {
        /**
          * Indicates if the input is disabled
         */
        "disabled": boolean;
        /**
          * @prop {string} errorText - The error message to display when validation fails.
         */
        "errorText": string;
        /**
          * Help text to display below the input
         */
        "helpText": string;
        /**
          * Label for the text field
         */
        "label": string;
        /**
          * @prop {string} nameValue - The name attribute for the input. Default is 'default'.
         */
        "nameValue": string;
        /**
          * Placeholder text for the input
         */
        "placeholder": string;
        /**
          * Indicates if the input is required
         */
        "required": boolean;
        /**
          * Input type (e.g., text, password, email)
         */
        "type": 'text' | 'password' | 'email' | 'number' | 'time';
        /**
          * Value of the input field
         */
        "value"?: string;
    }
    interface OToast {
        /**
          * Set to true to make the toast closable.
         */
        "closable": boolean;
        /**
          * The length of time, in milliseconds, the toast will show before closing itself.
         */
        "duration": number;
        /**
          * Hides the toast.
         */
        "hide": () => Promise<void>;
        /**
          * Indicates whether or not the toast is open.
         */
        "open": boolean;
        /**
          * Shows the toast.
         */
        "show": () => Promise<void>;
        /**
          * Displays the toast notification.
         */
        "toast": () => Promise<void>;
        /**
          * The variant of the toast.
         */
        "variant": 'primary' | 'success' | 'neutral' | 'warning' | 'danger';
    }
    interface OTooltip {
        /**
          * The text content to be displayed in the tooltip
         */
        "content": string;
        /**
          * Whether the tooltip is disabled, preventing user interaction.
         */
        "disabled": boolean;
        "hide": () => Promise<any>;
        /**
          * If true, sets the popup positioning strategy to fixed instead of absolute - can be used to get around overflow issues
         */
        "hoist": boolean;
        /**
          * Maximum width (in rem) of the tooltip popover, allowing optional text wrapping
         */
        "maxWidth": number | null;
        /**
          * The open state of the tooltip, defaults to closed (false)
         */
        "open": boolean;
        /**
          * Position of the tooltip relative to the target
         */
        "placement": | 'top'
		| 'top-start'
		| 'top-end'
		| 'bottom'
		| 'bottom-start'
		| 'bottom-end'
		| 'right'
		| 'right-start'
		| 'right-end'
		| 'left'
		| 'left-start'
		| 'left-end';
        "show": () => Promise<any>;
        /**
          * The trigger type of the tooltip, separated by a space - can be hover, focus, click, manual, or a combination
         */
        "trigger": string;
    }
}
export interface OAlertCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLOAlertElement;
}
export interface OCarouselCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLOCarouselElement;
}
export interface OCheckboxCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLOCheckboxElement;
}
export interface ODialogCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLODialogElement;
}
export interface ODrawerCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLODrawerElement;
}
export interface OListCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLOListElement;
}
export interface OListItemCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLOListItemElement;
}
export interface OMenuCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLOMenuElement;
}
export interface ORadioGroupCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLORadioGroupElement;
}
export interface OSelectCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLOSelectElement;
}
export interface OStepCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLOStepElement;
}
export interface OStepperCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLOStepperElement;
}
export interface OTabGroupCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLOTabGroupElement;
}
export interface OTagCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLOTagElement;
}
export interface OToastCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLOToastElement;
}
export interface OTooltipCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLOTooltipElement;
}
declare global {
    interface HTMLOAlertElementEventMap {
        "oShow": void;
        "oHide": void;
    }
    interface HTMLOAlertElement extends Components.OAlert, HTMLStencilElement {
        addEventListener<K extends keyof HTMLOAlertElementEventMap>(type: K, listener: (this: HTMLOAlertElement, ev: OAlertCustomEvent<HTMLOAlertElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLOAlertElementEventMap>(type: K, listener: (this: HTMLOAlertElement, ev: OAlertCustomEvent<HTMLOAlertElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLOAlertElement: {
        prototype: HTMLOAlertElement;
        new (): HTMLOAlertElement;
    };
    interface HTMLOAppBarElement extends Components.OAppBar, HTMLStencilElement {
    }
    var HTMLOAppBarElement: {
        prototype: HTMLOAppBarElement;
        new (): HTMLOAppBarElement;
    };
    interface HTMLOAvatarElement extends Components.OAvatar, HTMLStencilElement {
    }
    var HTMLOAvatarElement: {
        prototype: HTMLOAvatarElement;
        new (): HTMLOAvatarElement;
    };
    interface HTMLOBadgeElement extends Components.OBadge, HTMLStencilElement {
    }
    var HTMLOBadgeElement: {
        prototype: HTMLOBadgeElement;
        new (): HTMLOBadgeElement;
    };
    /**
     * OButton component supports different variants, colors, and states.
     * @component 
     * @since 0.1.0
     * @example ```html
     * <o-button variant="primary" color="brand">Click me</o-button>
     * ```
     */
    interface HTMLOButtonElement extends Components.OButton, HTMLStencilElement {
    }
    var HTMLOButtonElement: {
        prototype: HTMLOButtonElement;
        new (): HTMLOButtonElement;
    };
    interface HTMLOButtonGroupElement extends Components.OButtonGroup, HTMLStencilElement {
    }
    var HTMLOButtonGroupElement: {
        prototype: HTMLOButtonGroupElement;
        new (): HTMLOButtonGroupElement;
    };
    interface HTMLOCalloutElement extends Components.OCallout, HTMLStencilElement {
    }
    var HTMLOCalloutElement: {
        prototype: HTMLOCalloutElement;
        new (): HTMLOCalloutElement;
    };
    interface HTMLOCardElement extends Components.OCard, HTMLStencilElement {
    }
    var HTMLOCardElement: {
        prototype: HTMLOCardElement;
        new (): HTMLOCardElement;
    };
    interface HTMLOCarouselElementEventMap {
        "oSlideChange": { index: number; slide: HTMLOCarouselItemElement };
    }
    interface HTMLOCarouselElement extends Components.OCarousel, HTMLStencilElement {
        addEventListener<K extends keyof HTMLOCarouselElementEventMap>(type: K, listener: (this: HTMLOCarouselElement, ev: OCarouselCustomEvent<HTMLOCarouselElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLOCarouselElementEventMap>(type: K, listener: (this: HTMLOCarouselElement, ev: OCarouselCustomEvent<HTMLOCarouselElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLOCarouselElement: {
        prototype: HTMLOCarouselElement;
        new (): HTMLOCarouselElement;
    };
    interface HTMLOCarouselItemElement extends Components.OCarouselItem, HTMLStencilElement {
    }
    var HTMLOCarouselItemElement: {
        prototype: HTMLOCarouselItemElement;
        new (): HTMLOCarouselItemElement;
    };
    interface HTMLOCheckboxElementEventMap {
        "oChange": { checked: boolean };
    }
    interface HTMLOCheckboxElement extends Components.OCheckbox, HTMLStencilElement {
        addEventListener<K extends keyof HTMLOCheckboxElementEventMap>(type: K, listener: (this: HTMLOCheckboxElement, ev: OCheckboxCustomEvent<HTMLOCheckboxElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLOCheckboxElementEventMap>(type: K, listener: (this: HTMLOCheckboxElement, ev: OCheckboxCustomEvent<HTMLOCheckboxElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLOCheckboxElement: {
        prototype: HTMLOCheckboxElement;
        new (): HTMLOCheckboxElement;
    };
    interface HTMLODialogElementEventMap {
        "oShow": void;
        "oHide": void;
        "oRequestClose": { source: 'close-button' | 'keyboard' | 'overlay' };
    }
    interface HTMLODialogElement extends Components.ODialog, HTMLStencilElement {
        addEventListener<K extends keyof HTMLODialogElementEventMap>(type: K, listener: (this: HTMLODialogElement, ev: ODialogCustomEvent<HTMLODialogElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLODialogElementEventMap>(type: K, listener: (this: HTMLODialogElement, ev: ODialogCustomEvent<HTMLODialogElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLODialogElement: {
        prototype: HTMLODialogElement;
        new (): HTMLODialogElement;
    };
    interface HTMLODividerElement extends Components.ODivider, HTMLStencilElement {
    }
    var HTMLODividerElement: {
        prototype: HTMLODividerElement;
        new (): HTMLODividerElement;
    };
    interface HTMLODrawerElementEventMap {
        "oShow": void;
        "oHide": void;
        "oRequestClose": { source: 'close-button' | 'keyboard' | 'overlay' };
    }
    interface HTMLODrawerElement extends Components.ODrawer, HTMLStencilElement {
        addEventListener<K extends keyof HTMLODrawerElementEventMap>(type: K, listener: (this: HTMLODrawerElement, ev: ODrawerCustomEvent<HTMLODrawerElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLODrawerElementEventMap>(type: K, listener: (this: HTMLODrawerElement, ev: ODrawerCustomEvent<HTMLODrawerElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLODrawerElement: {
        prototype: HTMLODrawerElement;
        new (): HTMLODrawerElement;
    };
    interface HTMLODropdownElement extends Components.ODropdown, HTMLStencilElement {
    }
    var HTMLODropdownElement: {
        prototype: HTMLODropdownElement;
        new (): HTMLODropdownElement;
    };
    interface HTMLOFooterElement extends Components.OFooter, HTMLStencilElement {
    }
    var HTMLOFooterElement: {
        prototype: HTMLOFooterElement;
        new (): HTMLOFooterElement;
    };
    interface HTMLOIconElement extends Components.OIcon, HTMLStencilElement {
    }
    var HTMLOIconElement: {
        prototype: HTMLOIconElement;
        new (): HTMLOIconElement;
    };
    interface HTMLOIconButtonElement extends Components.OIconButton, HTMLStencilElement {
    }
    var HTMLOIconButtonElement: {
        prototype: HTMLOIconButtonElement;
        new (): HTMLOIconButtonElement;
    };
    interface HTMLOLabelElement extends Components.OLabel, HTMLStencilElement {
    }
    var HTMLOLabelElement: {
        prototype: HTMLOLabelElement;
        new (): HTMLOLabelElement;
    };
    interface HTMLOListElementEventMap {
        "oItemSelected": { value: string };
        "oValueChange": { value: string };
    }
    interface HTMLOListElement extends Components.OList, HTMLStencilElement {
        addEventListener<K extends keyof HTMLOListElementEventMap>(type: K, listener: (this: HTMLOListElement, ev: OListCustomEvent<HTMLOListElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLOListElementEventMap>(type: K, listener: (this: HTMLOListElement, ev: OListCustomEvent<HTMLOListElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLOListElement: {
        prototype: HTMLOListElement;
        new (): HTMLOListElement;
    };
    interface HTMLOListItemElementEventMap {
        "oItemClick": { value: string; native: MouseEvent };
    }
    interface HTMLOListItemElement extends Components.OListItem, HTMLStencilElement {
        addEventListener<K extends keyof HTMLOListItemElementEventMap>(type: K, listener: (this: HTMLOListItemElement, ev: OListItemCustomEvent<HTMLOListItemElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLOListItemElementEventMap>(type: K, listener: (this: HTMLOListItemElement, ev: OListItemCustomEvent<HTMLOListItemElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLOListItemElement: {
        prototype: HTMLOListItemElement;
        new (): HTMLOListItemElement;
    };
    interface HTMLOMenuElementEventMap {
        "oMenuSelect": OMenuSelectPayload;
    }
    interface HTMLOMenuElement extends Components.OMenu, HTMLStencilElement {
        addEventListener<K extends keyof HTMLOMenuElementEventMap>(type: K, listener: (this: HTMLOMenuElement, ev: OMenuCustomEvent<HTMLOMenuElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLOMenuElementEventMap>(type: K, listener: (this: HTMLOMenuElement, ev: OMenuCustomEvent<HTMLOMenuElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLOMenuElement: {
        prototype: HTMLOMenuElement;
        new (): HTMLOMenuElement;
    };
    interface HTMLOMenuItemElement extends Components.OMenuItem, HTMLStencilElement {
    }
    var HTMLOMenuItemElement: {
        prototype: HTMLOMenuItemElement;
        new (): HTMLOMenuItemElement;
    };
    interface HTMLOMenuLabelElement extends Components.OMenuLabel, HTMLStencilElement {
    }
    var HTMLOMenuLabelElement: {
        prototype: HTMLOMenuLabelElement;
        new (): HTMLOMenuLabelElement;
    };
    interface HTMLOOptionElement extends Components.OOption, HTMLStencilElement {
    }
    var HTMLOOptionElement: {
        prototype: HTMLOOptionElement;
        new (): HTMLOOptionElement;
    };
    interface HTMLOPopupElement extends Components.OPopup, HTMLStencilElement {
    }
    var HTMLOPopupElement: {
        prototype: HTMLOPopupElement;
        new (): HTMLOPopupElement;
    };
    interface HTMLORadioElement extends Components.ORadio, HTMLStencilElement {
    }
    var HTMLORadioElement: {
        prototype: HTMLORadioElement;
        new (): HTMLORadioElement;
    };
    interface HTMLORadioGroupElementEventMap {
        "oChange": { value: string };
    }
    interface HTMLORadioGroupElement extends Components.ORadioGroup, HTMLStencilElement {
        addEventListener<K extends keyof HTMLORadioGroupElementEventMap>(type: K, listener: (this: HTMLORadioGroupElement, ev: ORadioGroupCustomEvent<HTMLORadioGroupElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLORadioGroupElementEventMap>(type: K, listener: (this: HTMLORadioGroupElement, ev: ORadioGroupCustomEvent<HTMLORadioGroupElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLORadioGroupElement: {
        prototype: HTMLORadioGroupElement;
        new (): HTMLORadioGroupElement;
    };
    interface HTMLOSelectElementEventMap {
        "oChange": { value: string };
    }
    interface HTMLOSelectElement extends Components.OSelect, HTMLStencilElement {
        addEventListener<K extends keyof HTMLOSelectElementEventMap>(type: K, listener: (this: HTMLOSelectElement, ev: OSelectCustomEvent<HTMLOSelectElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLOSelectElementEventMap>(type: K, listener: (this: HTMLOSelectElement, ev: OSelectCustomEvent<HTMLOSelectElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLOSelectElement: {
        prototype: HTMLOSelectElement;
        new (): HTMLOSelectElement;
    };
    interface HTMLOSidebarElement extends Components.OSidebar, HTMLStencilElement {
    }
    var HTMLOSidebarElement: {
        prototype: HTMLOSidebarElement;
        new (): HTMLOSidebarElement;
    };
    interface HTMLOSkeletonElement extends Components.OSkeleton, HTMLStencilElement {
    }
    var HTMLOSkeletonElement: {
        prototype: HTMLOSkeletonElement;
        new (): HTMLOSkeletonElement;
    };
    interface HTMLOStepElementEventMap {
        "oSelectedChanged": HTMLOStepElement;
    }
    interface HTMLOStepElement extends Components.OStep, HTMLStencilElement {
        addEventListener<K extends keyof HTMLOStepElementEventMap>(type: K, listener: (this: HTMLOStepElement, ev: OStepCustomEvent<HTMLOStepElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLOStepElementEventMap>(type: K, listener: (this: HTMLOStepElement, ev: OStepCustomEvent<HTMLOStepElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLOStepElement: {
        prototype: HTMLOStepElement;
        new (): HTMLOStepElement;
    };
    interface HTMLOStepperElementEventMap {
        "oStepSelected": number;
    }
    interface HTMLOStepperElement extends Components.OStepper, HTMLStencilElement {
        addEventListener<K extends keyof HTMLOStepperElementEventMap>(type: K, listener: (this: HTMLOStepperElement, ev: OStepperCustomEvent<HTMLOStepperElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLOStepperElementEventMap>(type: K, listener: (this: HTMLOStepperElement, ev: OStepperCustomEvent<HTMLOStepperElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLOStepperElement: {
        prototype: HTMLOStepperElement;
        new (): HTMLOStepperElement;
    };
    interface HTMLOTabElement extends Components.OTab, HTMLStencilElement {
    }
    var HTMLOTabElement: {
        prototype: HTMLOTabElement;
        new (): HTMLOTabElement;
    };
    interface HTMLOTabGroupElementEventMap {
        "oTabShow": OTabShowPayload;
        "oTabHide": OTabHidePayload;
    }
    interface HTMLOTabGroupElement extends Components.OTabGroup, HTMLStencilElement {
        addEventListener<K extends keyof HTMLOTabGroupElementEventMap>(type: K, listener: (this: HTMLOTabGroupElement, ev: OTabGroupCustomEvent<HTMLOTabGroupElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLOTabGroupElementEventMap>(type: K, listener: (this: HTMLOTabGroupElement, ev: OTabGroupCustomEvent<HTMLOTabGroupElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLOTabGroupElement: {
        prototype: HTMLOTabGroupElement;
        new (): HTMLOTabGroupElement;
    };
    interface HTMLOTabPanelElement extends Components.OTabPanel, HTMLStencilElement {
    }
    var HTMLOTabPanelElement: {
        prototype: HTMLOTabPanelElement;
        new (): HTMLOTabPanelElement;
    };
    interface HTMLOTableElement extends Components.OTable, HTMLStencilElement {
    }
    var HTMLOTableElement: {
        prototype: HTMLOTableElement;
        new (): HTMLOTableElement;
    };
    interface HTMLOTagElementEventMap {
        "oRemove": void;
        "oClick": void;
    }
    interface HTMLOTagElement extends Components.OTag, HTMLStencilElement {
        addEventListener<K extends keyof HTMLOTagElementEventMap>(type: K, listener: (this: HTMLOTagElement, ev: OTagCustomEvent<HTMLOTagElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLOTagElementEventMap>(type: K, listener: (this: HTMLOTagElement, ev: OTagCustomEvent<HTMLOTagElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLOTagElement: {
        prototype: HTMLOTagElement;
        new (): HTMLOTagElement;
    };
    interface HTMLOTextareaElement extends Components.OTextarea, HTMLStencilElement {
    }
    var HTMLOTextareaElement: {
        prototype: HTMLOTextareaElement;
        new (): HTMLOTextareaElement;
    };
    interface HTMLOTextfieldElement extends Components.OTextfield, HTMLStencilElement {
    }
    var HTMLOTextfieldElement: {
        prototype: HTMLOTextfieldElement;
        new (): HTMLOTextfieldElement;
    };
    interface HTMLOToastElementEventMap {
        "oShow": void;
        "oHide": void;
    }
    interface HTMLOToastElement extends Components.OToast, HTMLStencilElement {
        addEventListener<K extends keyof HTMLOToastElementEventMap>(type: K, listener: (this: HTMLOToastElement, ev: OToastCustomEvent<HTMLOToastElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLOToastElementEventMap>(type: K, listener: (this: HTMLOToastElement, ev: OToastCustomEvent<HTMLOToastElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLOToastElement: {
        prototype: HTMLOToastElement;
        new (): HTMLOToastElement;
    };
    interface HTMLOTooltipElementEventMap {
        "oShow": void;
        "oHide": void;
        "oAfterShow": void;
        "oAfterHide": void;
    }
    interface HTMLOTooltipElement extends Components.OTooltip, HTMLStencilElement {
        addEventListener<K extends keyof HTMLOTooltipElementEventMap>(type: K, listener: (this: HTMLOTooltipElement, ev: OTooltipCustomEvent<HTMLOTooltipElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLOTooltipElementEventMap>(type: K, listener: (this: HTMLOTooltipElement, ev: OTooltipCustomEvent<HTMLOTooltipElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLOTooltipElement: {
        prototype: HTMLOTooltipElement;
        new (): HTMLOTooltipElement;
    };
    interface HTMLElementTagNameMap {
        "o-alert": HTMLOAlertElement;
        "o-app-bar": HTMLOAppBarElement;
        "o-avatar": HTMLOAvatarElement;
        "o-badge": HTMLOBadgeElement;
        "o-button": HTMLOButtonElement;
        "o-button-group": HTMLOButtonGroupElement;
        "o-callout": HTMLOCalloutElement;
        "o-card": HTMLOCardElement;
        "o-carousel": HTMLOCarouselElement;
        "o-carousel-item": HTMLOCarouselItemElement;
        "o-checkbox": HTMLOCheckboxElement;
        "o-dialog": HTMLODialogElement;
        "o-divider": HTMLODividerElement;
        "o-drawer": HTMLODrawerElement;
        "o-dropdown": HTMLODropdownElement;
        "o-footer": HTMLOFooterElement;
        "o-icon": HTMLOIconElement;
        "o-icon-button": HTMLOIconButtonElement;
        "o-label": HTMLOLabelElement;
        "o-list": HTMLOListElement;
        "o-list-item": HTMLOListItemElement;
        "o-menu": HTMLOMenuElement;
        "o-menu-item": HTMLOMenuItemElement;
        "o-menu-label": HTMLOMenuLabelElement;
        "o-option": HTMLOOptionElement;
        "o-popup": HTMLOPopupElement;
        "o-radio": HTMLORadioElement;
        "o-radio-group": HTMLORadioGroupElement;
        "o-select": HTMLOSelectElement;
        "o-sidebar": HTMLOSidebarElement;
        "o-skeleton": HTMLOSkeletonElement;
        "o-step": HTMLOStepElement;
        "o-stepper": HTMLOStepperElement;
        "o-tab": HTMLOTabElement;
        "o-tab-group": HTMLOTabGroupElement;
        "o-tab-panel": HTMLOTabPanelElement;
        "o-table": HTMLOTableElement;
        "o-tag": HTMLOTagElement;
        "o-textarea": HTMLOTextareaElement;
        "o-textfield": HTMLOTextfieldElement;
        "o-toast": HTMLOToastElement;
        "o-tooltip": HTMLOTooltipElement;
    }
}
declare namespace LocalJSX {
    interface OAlert {
        /**
          * Emitted when the alert closes.
         */
        "onOHide"?: (event: OAlertCustomEvent<void>) => void;
        /**
          * Emitted when the alert opens.
         */
        "onOShow"?: (event: OAlertCustomEvent<void>) => void;
        /**
          * Indicates whether or not the alert is open.
         */
        "open"?: boolean;
        /**
          * The variant of the alert.
         */
        "variant"?: 'primary' | 'success' | 'neutral' | 'warning' | 'danger';
    }
    interface OAppBar {
        /**
          * A description that gets read by assistive devices.
         */
        "label"?: string;
    }
    interface OAvatar {
        /**
          * Optional full name (first and last)
         */
        "initials"?: string;
        /**
          * Label for Accessability purposes
         */
        "label"?: string;
    }
    interface OBadge {
        /**
          * The color of the badge, can be "brand", "order", "payment", "shipping", "uncategorized"
         */
        "color"?: 'brand' | 'order' | 'payment' | 'shipping' | 'uncategorized';
        /**
          * @prop variant - The variant of the component, which determines its style.
          * @deprecated The prop 'variant' is deprecated as of v0.6.0
          * @see {@link http://oecui.oec.oeconnection.com/?path=/docs/components-badge--docs} OBadge Documentation
          * @since 0.1.0 - Initial introduction of variant prop
          * @since 0.6.0 - Variant prop deprecated
         */
        "variant"?: 'default' | 'order' | 'neutral' | 'shipping' | 'payment';
    }
    /**
     * OButton component supports different variants, colors, and states.
     * @component 
     * @since 0.1.0
     * @example ```html
     * <o-button variant="primary" color="brand">Click me</o-button>
     * ```
     */
    interface OButton {
        /**
          * The color theme of the button.
          * @prop color
          * @type {'brand' | 'buyer' | 'seller' | 'payment' | 'order' | 'shipping'}
          * @default 'brand'
          * @since 0.6.0
         */
        "color"?: 'brand' | 'buyer' | 'seller' | 'payment' | 'order' | 'shipping';
        /**
          * Indicates whether the button is disabled, preventing user interaction.
          * @prop disabled
          * @type {boolean}
          * @default false
          * @since 0.1.0
         */
        "disabled"?: boolean;
        /**
          * Indicates whether the button takes up the full width of the container.
          * @prop fullWidth
          * @type {boolean}
          * @default false
          * @since 0.2.0
         */
        "fullWidth"?: boolean;
        /**
          * Indicates whether the button is part of a button group.
          * @prop isButtonGroup
          * @type {boolean}
          * @default false
          * @since 0.1.0
         */
        "isButtonGroup"?: boolean;
        /**
          * Indicates whether the button is loading, preventing user interaction.
          * @prop loading
          * @type {boolean}
          * @default false
          * @since 0.3.0
         */
        "loading"?: boolean;
        /**
          * The type of the button.
          * @prop type
          * @type {'button' | 'submit' | 'reset'}
          * @default 'submit'
          * @since 0.4.0
         */
        "type"?: 'button' | 'submit' | 'reset';
        /**
          * The visual style variant of the OButton.
          * @prop variant
          * @type {'primary' | 'secondary' | 'text'}
          * @default 'primary'
          * @since 0.1.0
         */
        "variant"?: 'primary' | 'secondary' | 'text';
    }
    interface OButtonGroup {
    }
    interface OCallout {
    }
    interface OCard {
    }
    interface OCarousel {
        "navigation"?: boolean;
        "onOSlideChange"?: (event: OCarouselCustomEvent<{ index: number; slide: HTMLOCarouselItemElement }>) => void;
        "pagination"?: boolean;
    }
    interface OCarouselItem {
    }
    interface OCheckbox {
        /**
          * Determines the initial checked state of the checkbox.
         */
        "checked"?: boolean;
        /**
          * @prop {boolean} disabled - Whether the input is disabled. Default is false.
         */
        "disabled"?: boolean;
        /**
          * @prop {string} errorText - The error message to display when validation fails.
         */
        "errorText"?: string;
        /**
          * @prop {boolean} indeterminate - Whether the checkbox is in an indeterminate state.
         */
        "indeterminate"?: boolean;
        /**
          * Used for Storybook documentation purposes.
         */
        "label"?: string;
        /**
          * @prop {string} nameValue - The name attribute for the checkbox. Default is 'default'.
         */
        "nameValue"?: string;
        /**
          * @event oChange
         */
        "onOChange"?: (event: OCheckboxCustomEvent<{ checked: boolean }>) => void;
        /**
          * @prop {boolean} required - Indicates if the checkbox is required
         */
        "required"?: boolean;
        /**
          * @prop {string} value - The value of the checkbox input.
         */
        "value"?: string;
    }
    interface ODialog {
        /**
          * The label for the dialog header.
         */
        "label"?: string;
        /**
          * Determines whether the close button is shown.
         */
        "noClose"?: boolean;
        /**
          * Emitted when the dialog closes
         */
        "onOHide"?: (event: ODialogCustomEvent<void>) => void;
        /**
          * Emitted when dialog close is requested with the source of the request
         */
        "onORequestClose"?: (event: ODialogCustomEvent<{ source: 'close-button' | 'keyboard' | 'overlay' }>) => void;
        /**
          * Emitted when the dialog opens
         */
        "onOShow"?: (event: ODialogCustomEvent<void>) => void;
        /**
          * Indicates whether or not the dialog is open.
         */
        "open"?: boolean;
    }
    interface ODivider {
        /**
          * Divider variant: 'horizontal' (default) or 'vertical'
         */
        "variant"?: 'horizontal' | 'vertical';
    }
    interface ODrawer {
        /**
          * The label for the aria label.
         */
        "label"?: string;
        /**
          * Determines whether the close button is shown.
         */
        "noClose"?: boolean;
        /**
          * Emitted when the drawer closes
         */
        "onOHide"?: (event: ODrawerCustomEvent<void>) => void;
        /**
          * Emitted when drawer close is requested with the source of the request
         */
        "onORequestClose"?: (event: ODrawerCustomEvent<{ source: 'close-button' | 'keyboard' | 'overlay' }>) => void;
        /**
          * Emitted when the drawer opens
         */
        "onOShow"?: (event: ODrawerCustomEvent<void>) => void;
        /**
          * Indicates whether or not the drawer is open.
         */
        "open"?: boolean;
    }
    interface ODropdown {
        "disabled"?: boolean;
        "open"?: boolean;
        "placement"?: | 'top'
		| 'top-start'
		| 'top-end'
		| 'bottom'
		| 'bottom-start'
		| 'bottom-end'
		| 'right'
		| 'right-start'
		| 'right-end'
		| 'left'
		| 'left-start'
		| 'left-end';
    }
    interface OFooter {
    }
    interface OIcon {
        /**
          * Optional color for the icon, can be a hex value or a color name.
         */
        "color"?: string;
        /**
          * The name of the icon to be rendered.
         */
        "name"?: IconName;
        /**
          * The size of the icon, can be 'sm', 'md', 'lg'.
         */
        "size"?: 'sm' | 'md' | 'lg';
    }
    interface OIconButton {
        /**
          * Optional color for the icon, can be a hex value or a color name.
         */
        "color"?: string;
        /**
          * Indicates whether the button is disabled, preventing user interaction.
         */
        "disabled"?: boolean;
        /**
          * A description that gets read by assistive devices.
         */
        "label"?: string;
        /**
          * The name of the icon to be rendered.
         */
        "name"?: IconName;
        /**
          * The size of the icon, can be 'sm', 'md', 'lg'.
         */
        "size"?: 'sm' | 'md' | 'lg';
        /**
          * The type of the button, can be "button", "submit", "reset".
         */
        "type"?: 'button' | 'submit' | 'reset';
    }
    interface OLabel {
        /**
          * The ID of the input element the label is associated with
         */
        "htmlFor"?: string;
        /**
          * The label text to display
         */
        "label"?: string;
        /**
          * Indicates if the field is required - shows asterisk
         */
        "required"?: boolean;
        /**
          * Variant for different label states
         */
        "variant"?: 'error' | 'disabled';
    }
    interface OList {
        "errorText"?: string;
        "helpText"?: string;
        "label"?: string;
        "name"?: string;
        "onOItemSelected"?: (event: OListCustomEvent<{ value: string }>) => void;
        /**
          * Emitted when the list item value changes
         */
        "onOValueChange"?: (event: OListCustomEvent<{ value: string }>) => void;
        "required"?: boolean;
        "showRadio"?: boolean;
        "value"?: string;
    }
    interface OListItem {
        "disabled"?: boolean;
        "name"?: string;
        "onOItemClick"?: (event: OListItemCustomEvent<{ value: string; native: MouseEvent }>) => void;
        "selected"?: boolean;
        "value"?: string;
    }
    interface OMenu {
        "onOMenuSelect"?: (event: OMenuCustomEvent<OMenuSelectPayload>) => void;
    }
    interface OMenuItem {
        "disabled"?: boolean;
        "index"?: 0 | -1;
        "value"?: string;
    }
    interface OMenuLabel {
    }
    interface OOption {
        "current"?: boolean;
        "disabled"?: boolean;
        "selected"?: boolean;
        "value"?: string;
    }
    interface OPopup {
        /**
          * The open state of the popup, defaults to closed (false)
         */
        "active"?: boolean;
        /**
          * Sets whether an arrow displays along the bottom edge of the popup
         */
        "arrow"?: boolean;
        /**
          * Determines amount of space between anchor and popup content, defaults to zero
         */
        "distance"?: number;
        /**
          * Allows popup to change position on axis to remain in view, defaults to false
         */
        "flip"?: boolean;
        /**
          * Allows for creation of element between popup and anchor when popup is active to maintain hover state
         */
        "hoverBridge"?: boolean;
        /**
          * Position of the popup relative to the anchor
         */
        "placement"?: | 'top'
		| 'top-start'
		| 'top-end'
		| 'bottom'
		| 'bottom-start'
		| 'bottom-end'
		| 'right'
		| 'right-start'
		| 'right-end'
		| 'left'
		| 'left-start'
		| 'left-end';
        /**
          * Sets whether popup uses fixed positioning, defaults to absolute
         */
        "strategy"?: 'absolute' | 'fixed';
        /**
          * Syncs sizing of popup content to anchor sizing
         */
        "sync"?: 'width' | 'height' | 'both';
    }
    interface ORadio {
        /**
          * @prop {boolean} checked - Determines the initial checked state of the radio. Default is false.
         */
        "checked"?: boolean;
        /**
          * @prop {boolean} disabled - Whether the input is disabled. Default is false.
         */
        "disabled"?: boolean;
        /**
          * @prop {string} label - The label text for the radio input.
         */
        "label"?: string;
        /**
          * @prop {string} name - The name attribute for the radio input. Used to bind radios together in a radio group.
         */
        "name"?: string;
        /**
          * @prop {string} nameValue - The id attribute for the radio input.
         */
        "nameValue"?: string;
        /**
          * @prop {string} value - The value attribute for the radio input.
         */
        "value"?: string;
    }
    interface ORadioGroup {
        /**
          * @prop {string} errorText - The error message to display when validation fails.
         */
        "errorText"?: string;
        /**
          * @prop {string} helpText - The help text to display below the radio group.
         */
        "helpText"?: string;
        /**
          * @prop {string} label - The label text for the radio group.
         */
        "label"?: string;
        /**
          * @prop {string} name - The name attribute used to bind the child radios together.
         */
        "name"?: string;
        /**
          * Emitted when the radio group value changes
         */
        "onOChange"?: (event: ORadioGroupCustomEvent<{ value: string }>) => void;
        /**
          * @prop {boolean} required - Whether selection from the radio group is required. Default is false.
         */
        "required"?: boolean;
        /**
          * @prop {string} value - The value attribute for the radio group.
         */
        "value"?: string;
    }
    interface OSelect {
        "disabled"?: boolean;
        "errorText"?: string;
        "helpText"?: string;
        "label"?: string;
        "nameValue"?: string;
        /**
          * Emitted when the select value changes
         */
        "onOChange"?: (event: OSelectCustomEvent<{ value: string }>) => void;
        "open"?: boolean;
        "placeholder"?: string;
        "placement"?: 'top' | 'bottom';
        "required"?: boolean;
        "value"?: string;
    }
    interface OSidebar {
    }
    interface OSkeleton {
    }
    interface OStep {
        /**
          * Enables click interaction for the step
         */
        "clickable"?: boolean;
        /**
          * (Circle Number) Index of the step (starting from 1)
         */
        "index"?: number;
        /**
          * Emitted when the step is clicked and its selection state changes
         */
        "onOSelectedChanged"?: (event: OStepCustomEvent<HTMLOStepElement>) => void;
        /**
          * Position of the step within the stepper (internal)
         */
        "position"?: 'first' | 'last' | 'single' | 'inner';
        /**
          * Indicates whether the step is currently selected
         */
        "selected"?: boolean;
        /**
          * Visual variant of the step
         */
        "variant"?: 'completed' | 'active' | 'default' | 'error';
    }
    interface OStepper {
        /**
          * Enables click navigation on the steps
         */
        "clickable"?: boolean;
        /**
          * Emitted when the selected step changes
         */
        "onOStepSelected"?: (event: OStepperCustomEvent<number>) => void;
        /**
          * The index of the currently selected step
         */
        "selectedIndex"?: number;
    }
    interface OTab {
        /**
          * Set to true to draw the tab in an active state.
         */
        "active"?: boolean;
        /**
          * Set to true to draw the tab in a disabled state.
         */
        "disabled"?: boolean;
        /**
          * The name of the tab panel the tab will control. The panel must be located in the same tab group.
         */
        "panel"?: string;
    }
    interface OTabGroup {
        /**
          * Disables the scroll arrows that appear when tabs overflow.
         */
        "noScrollControls"?: boolean;
        /**
          * Emitted when a tab is hidden.
         */
        "onOTabHide"?: (event: OTabGroupCustomEvent<OTabHidePayload>) => void;
        /**
          * Emitted when a tab is shown.
         */
        "onOTabShow"?: (event: OTabGroupCustomEvent<OTabShowPayload>) => void;
        /**
          * The placement of the tabs.
         */
        "placement"?: 'top';
    }
    interface OTabPanel {
        /**
          * When true, the tab panel will be shown.
         */
        "active"?: boolean;
        /**
          * The tab panel's name.
         */
        "name"?: string;
    }
    interface OTable {
    }
    interface OTag {
        /**
          * Determines if the tag is closable (shows a close button)
         */
        "closable"?: boolean;
        /**
          * Color variant of the tag
         */
        "color"?: 'brand' | 'order' | 'payment' | 'shipping' | 'uncategorized';
        /**
          * Event emitted when the tag is clicked
         */
        "onOClick"?: (event: OTagCustomEvent<void>) => void;
        /**
          * Event emitted when the close button is clicked
         */
        "onORemove"?: (event: OTagCustomEvent<void>) => void;
    }
    interface OTextarea {
        /**
          * @prop {boolean} disabled - Whether the textarea is disabled. Default is false.
         */
        "disabled"?: boolean;
        /**
          * @prop {string} errorText - The error message to display when validation fails.
         */
        "errorText"?: string;
        /**
          * @prop {string} helpText - The help text to display below the textarea.
         */
        "helpText"?: string;
        /**
          * @prop {string} label - The label text for the textarea.
         */
        "label"?: string;
        /**
          * @prop {string} nameValue - The name attribute for the input. Default is 'default'.
         */
        "nameValue"?: string;
        /**
          * @prop {string} placeholder - The placeholder text for the textarea.
         */
        "placeholder"?: string;
        /**
          * @prop {boolean} required - Whether the textarea is required. Default is false.
         */
        "required"?: boolean;
        /**
          * @prop {string} value - The current value of the textarea.
         */
        "value"?: string;
    }
    interface OTextfield {
        /**
          * Indicates if the input is disabled
         */
        "disabled"?: boolean;
        /**
          * @prop {string} errorText - The error message to display when validation fails.
         */
        "errorText"?: string;
        /**
          * Help text to display below the input
         */
        "helpText"?: string;
        /**
          * Label for the text field
         */
        "label"?: string;
        /**
          * @prop {string} nameValue - The name attribute for the input. Default is 'default'.
         */
        "nameValue"?: string;
        /**
          * Placeholder text for the input
         */
        "placeholder"?: string;
        /**
          * Indicates if the input is required
         */
        "required"?: boolean;
        /**
          * Input type (e.g., text, password, email)
         */
        "type"?: 'text' | 'password' | 'email' | 'number' | 'time';
        /**
          * Value of the input field
         */
        "value"?: string;
    }
    interface OToast {
        /**
          * Set to true to make the toast closable.
         */
        "closable"?: boolean;
        /**
          * The length of time, in milliseconds, the toast will show before closing itself.
         */
        "duration"?: number;
        /**
          * Emitted when the toast closes.
         */
        "onOHide"?: (event: OToastCustomEvent<void>) => void;
        /**
          * Emitted when the toast opens.
         */
        "onOShow"?: (event: OToastCustomEvent<void>) => void;
        /**
          * Indicates whether or not the toast is open.
         */
        "open"?: boolean;
        /**
          * The variant of the toast.
         */
        "variant"?: 'primary' | 'success' | 'neutral' | 'warning' | 'danger';
    }
    interface OTooltip {
        /**
          * The text content to be displayed in the tooltip
         */
        "content"?: string;
        /**
          * Whether the tooltip is disabled, preventing user interaction.
         */
        "disabled"?: boolean;
        /**
          * If true, sets the popup positioning strategy to fixed instead of absolute - can be used to get around overflow issues
         */
        "hoist"?: boolean;
        /**
          * Maximum width (in rem) of the tooltip popover, allowing optional text wrapping
         */
        "maxWidth"?: number | null;
        /**
          * Emitted after tooltip hidden
         */
        "onOAfterHide"?: (event: OTooltipCustomEvent<void>) => void;
        /**
          * Emitted after tooltip shown
         */
        "onOAfterShow"?: (event: OTooltipCustomEvent<void>) => void;
        /**
          * Emitted when tooltip hidden
         */
        "onOHide"?: (event: OTooltipCustomEvent<void>) => void;
        /**
          * Emitted when tooltip shown
         */
        "onOShow"?: (event: OTooltipCustomEvent<void>) => void;
        /**
          * The open state of the tooltip, defaults to closed (false)
         */
        "open"?: boolean;
        /**
          * Position of the tooltip relative to the target
         */
        "placement"?: | 'top'
		| 'top-start'
		| 'top-end'
		| 'bottom'
		| 'bottom-start'
		| 'bottom-end'
		| 'right'
		| 'right-start'
		| 'right-end'
		| 'left'
		| 'left-start'
		| 'left-end';
        /**
          * The trigger type of the tooltip, separated by a space - can be hover, focus, click, manual, or a combination
         */
        "trigger"?: string;
    }
    interface IntrinsicElements {
        "o-alert": OAlert;
        "o-app-bar": OAppBar;
        "o-avatar": OAvatar;
        "o-badge": OBadge;
        "o-button": OButton;
        "o-button-group": OButtonGroup;
        "o-callout": OCallout;
        "o-card": OCard;
        "o-carousel": OCarousel;
        "o-carousel-item": OCarouselItem;
        "o-checkbox": OCheckbox;
        "o-dialog": ODialog;
        "o-divider": ODivider;
        "o-drawer": ODrawer;
        "o-dropdown": ODropdown;
        "o-footer": OFooter;
        "o-icon": OIcon;
        "o-icon-button": OIconButton;
        "o-label": OLabel;
        "o-list": OList;
        "o-list-item": OListItem;
        "o-menu": OMenu;
        "o-menu-item": OMenuItem;
        "o-menu-label": OMenuLabel;
        "o-option": OOption;
        "o-popup": OPopup;
        "o-radio": ORadio;
        "o-radio-group": ORadioGroup;
        "o-select": OSelect;
        "o-sidebar": OSidebar;
        "o-skeleton": OSkeleton;
        "o-step": OStep;
        "o-stepper": OStepper;
        "o-tab": OTab;
        "o-tab-group": OTabGroup;
        "o-tab-panel": OTabPanel;
        "o-table": OTable;
        "o-tag": OTag;
        "o-textarea": OTextarea;
        "o-textfield": OTextfield;
        "o-toast": OToast;
        "o-tooltip": OTooltip;
    }
}
export { LocalJSX as JSX };
declare module "@stencil/core" {
    export namespace JSX {
        interface IntrinsicElements {
            "o-alert": LocalJSX.OAlert & JSXBase.HTMLAttributes<HTMLOAlertElement>;
            "o-app-bar": LocalJSX.OAppBar & JSXBase.HTMLAttributes<HTMLOAppBarElement>;
            "o-avatar": LocalJSX.OAvatar & JSXBase.HTMLAttributes<HTMLOAvatarElement>;
            "o-badge": LocalJSX.OBadge & JSXBase.HTMLAttributes<HTMLOBadgeElement>;
            /**
             * OButton component supports different variants, colors, and states.
             * @component 
             * @since 0.1.0
             * @example ```html
             * <o-button variant="primary" color="brand">Click me</o-button>
             * ```
             */
            "o-button": LocalJSX.OButton & JSXBase.HTMLAttributes<HTMLOButtonElement>;
            "o-button-group": LocalJSX.OButtonGroup & JSXBase.HTMLAttributes<HTMLOButtonGroupElement>;
            "o-callout": LocalJSX.OCallout & JSXBase.HTMLAttributes<HTMLOCalloutElement>;
            "o-card": LocalJSX.OCard & JSXBase.HTMLAttributes<HTMLOCardElement>;
            "o-carousel": LocalJSX.OCarousel & JSXBase.HTMLAttributes<HTMLOCarouselElement>;
            "o-carousel-item": LocalJSX.OCarouselItem & JSXBase.HTMLAttributes<HTMLOCarouselItemElement>;
            "o-checkbox": LocalJSX.OCheckbox & JSXBase.HTMLAttributes<HTMLOCheckboxElement>;
            "o-dialog": LocalJSX.ODialog & JSXBase.HTMLAttributes<HTMLODialogElement>;
            "o-divider": LocalJSX.ODivider & JSXBase.HTMLAttributes<HTMLODividerElement>;
            "o-drawer": LocalJSX.ODrawer & JSXBase.HTMLAttributes<HTMLODrawerElement>;
            "o-dropdown": LocalJSX.ODropdown & JSXBase.HTMLAttributes<HTMLODropdownElement>;
            "o-footer": LocalJSX.OFooter & JSXBase.HTMLAttributes<HTMLOFooterElement>;
            "o-icon": LocalJSX.OIcon & JSXBase.HTMLAttributes<HTMLOIconElement>;
            "o-icon-button": LocalJSX.OIconButton & JSXBase.HTMLAttributes<HTMLOIconButtonElement>;
            "o-label": LocalJSX.OLabel & JSXBase.HTMLAttributes<HTMLOLabelElement>;
            "o-list": LocalJSX.OList & JSXBase.HTMLAttributes<HTMLOListElement>;
            "o-list-item": LocalJSX.OListItem & JSXBase.HTMLAttributes<HTMLOListItemElement>;
            "o-menu": LocalJSX.OMenu & JSXBase.HTMLAttributes<HTMLOMenuElement>;
            "o-menu-item": LocalJSX.OMenuItem & JSXBase.HTMLAttributes<HTMLOMenuItemElement>;
            "o-menu-label": LocalJSX.OMenuLabel & JSXBase.HTMLAttributes<HTMLOMenuLabelElement>;
            "o-option": LocalJSX.OOption & JSXBase.HTMLAttributes<HTMLOOptionElement>;
            "o-popup": LocalJSX.OPopup & JSXBase.HTMLAttributes<HTMLOPopupElement>;
            "o-radio": LocalJSX.ORadio & JSXBase.HTMLAttributes<HTMLORadioElement>;
            "o-radio-group": LocalJSX.ORadioGroup & JSXBase.HTMLAttributes<HTMLORadioGroupElement>;
            "o-select": LocalJSX.OSelect & JSXBase.HTMLAttributes<HTMLOSelectElement>;
            "o-sidebar": LocalJSX.OSidebar & JSXBase.HTMLAttributes<HTMLOSidebarElement>;
            "o-skeleton": LocalJSX.OSkeleton & JSXBase.HTMLAttributes<HTMLOSkeletonElement>;
            "o-step": LocalJSX.OStep & JSXBase.HTMLAttributes<HTMLOStepElement>;
            "o-stepper": LocalJSX.OStepper & JSXBase.HTMLAttributes<HTMLOStepperElement>;
            "o-tab": LocalJSX.OTab & JSXBase.HTMLAttributes<HTMLOTabElement>;
            "o-tab-group": LocalJSX.OTabGroup & JSXBase.HTMLAttributes<HTMLOTabGroupElement>;
            "o-tab-panel": LocalJSX.OTabPanel & JSXBase.HTMLAttributes<HTMLOTabPanelElement>;
            "o-table": LocalJSX.OTable & JSXBase.HTMLAttributes<HTMLOTableElement>;
            "o-tag": LocalJSX.OTag & JSXBase.HTMLAttributes<HTMLOTagElement>;
            "o-textarea": LocalJSX.OTextarea & JSXBase.HTMLAttributes<HTMLOTextareaElement>;
            "o-textfield": LocalJSX.OTextfield & JSXBase.HTMLAttributes<HTMLOTextfieldElement>;
            "o-toast": LocalJSX.OToast & JSXBase.HTMLAttributes<HTMLOToastElement>;
            "o-tooltip": LocalJSX.OTooltip & JSXBase.HTMLAttributes<HTMLOTooltipElement>;
        }
    }
}
