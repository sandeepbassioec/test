{"version":3,"file":"index.js","sources":["../src/utils/string-utils.ts","../src/create-es-modules-components-file.ts","../src/create-stencil-react-components.ts","../src/create-tag-transformer.ts","../src/create-component-wrappers.ts","../src/create-native-types.ts","../src/index.ts"],"sourcesContent":["export const kebabToPascalCase = (str: string) =>\n  str\n    .toLowerCase()\n    .split('-')\n    .map((segment) => segment.charAt(0).toUpperCase() + segment.slice(1))\n    .join('');\n\nexport const kebabToCamelCase = (str: string) => str.replace(/-([_a-z])/g, (_, letter) => letter.toUpperCase());\n\nconst slashesToCamelCase = (str: string) => str.replace(/\\/([a-z])/g, (_, letter) => letter.toUpperCase());\n\nexport const eventListenerName = (eventName: string) => {\n  const slashesConverted = slashesToCamelCase(eventName);\n  return kebabToCamelCase(`on-${slashesConverted}`);\n};\n\n/**\n * Normalizes a type string by removing single-line comments and collapsing whitespace.\n * This is necessary because multiline types with comments would break when collapsed to a single line.\n */\nexport const normalizeTypeString = (type: string) =>\n  type\n    .replace(/\\/\\/.*$/gm, '') // Remove single-line comments\n    .replace(/\\n/g, ' ') // Replace newlines with spaces\n    .replace(/\\s{2,}/g, ' ') // Collapse multiple spaces\n    .trim();\n","import type { ComponentCompilerMeta } from '@stencil/core/internal';\nimport path from 'node:path';\nimport { Project } from 'ts-morph';\nimport { kebabToPascalCase } from './utils/string-utils.js';\n\nexport const createEsModulesComponentsFile = async ({\n  components,\n  project,\n  outDir,\n}: {\n  components: ComponentCompilerMeta[];\n  project?: Project;\n  outDir?: string;\n}) => {\n  const tsProject = project || new Project({ useInMemoryFileSystem: true });\n  const disableEslint = `/* eslint-disable */\\n`;\n  const autogeneratedComment = `/**\n * This file was automatically generated by the Stencil React Output Target.\n * Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.\n */\\n\\n`;\n  const outFile = path.join(outDir || '', 'components.ts');\n  const sourceFile = tsProject.createSourceFile(outFile, autogeneratedComment + disableEslint, {\n    overwrite: true,\n  });\n\n  for (const component of components) {\n    const tagName = component.tagName;\n    const reactTagName = kebabToPascalCase(tagName);\n    const fileName = component.tagName;\n    sourceFile.addExportDeclaration({\n      moduleSpecifier: `./${fileName}.js`,\n      namedExports: [reactTagName],\n    });\n  }\n\n  sourceFile.organizeImports();\n  sourceFile.formatText();\n  await sourceFile.save();\n\n  return sourceFile;\n};\n","import type { ComponentCompilerMeta } from '@stencil/core/internal';\nimport { Project, VariableDeclarationKind } from 'ts-morph';\nimport { eventListenerName, kebabToPascalCase, normalizeTypeString } from './utils/string-utils.js';\nimport type { RenderToStringOptions } from './runtime/ssr.js';\n\ninterface ReactEvent {\n  originalName: string;\n  name: string;\n  type: string;\n}\n\nexport const createStencilReactComponents = ({\n  components,\n  stencilPackageName,\n  customElementsDir,\n  hydrateModule,\n  clientModule,\n  serializeShadowRoot,\n  transformTag,\n}: {\n  components: ComponentCompilerMeta[];\n  stencilPackageName: string;\n  customElementsDir: string;\n  hydrateModule?: string;\n  clientModule?: string;\n  serializeShadowRoot?: RenderToStringOptions['serializeShadowRoot'];\n  transformTag?: boolean;\n}) => {\n  const project = new Project({ useInMemoryFileSystem: true });\n\n  /**\n   * automatically attach the `use client` directive if we are not generating\n   * server side rendering components.\n   */\n  const useClientDirective = !hydrateModule ? `'use client';\\n\\n` : '';\n  const autogeneratedComment = `/**\n * This file was automatically generated by the Stencil React Output Target.\n * Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.\n */\\n\\n`;\n\n  const disableEslint = `/* eslint-disable */\\n`;\n  const getTagTransformerImport = transformTag ? `import { getTagTransformer } from './tag-transformer.js';\\n` : '';\n  const createComponentImport = hydrateModule\n    ? [\n        `// @ts-ignore - ignore potential type issues as the project is importing itself`,\n        `import * as clientComponents from '${clientModule}';`,\n        getTagTransformerImport,\n        `import { createComponent, type SerializeShadowRootOptions, type HydrateModule, type ReactWebComponent, type DynamicFunction } from '@stencil/react-output-target/ssr';`,\n      ]\n        .filter(Boolean)\n        .join('\\n')\n    : `import { createComponent } from '@stencil/react-output-target/runtime';`;\n  // transformTag should be imported from tag-transformer for both client and server\n  const transformTagImport = transformTag ? `import { transformTag } from './tag-transformer.js';\\n` : '';\n  const sourceFile = project.createSourceFile(\n    'component.ts',\n    `${useClientDirective}${autogeneratedComment}${disableEslint}\nimport React from 'react';\n${createComponentImport}\nimport type { EventName, StencilReactComponent } from '@stencil/react-output-target/runtime';\n${transformTagImport}\n  `\n  );\n\n  /**\n   * Add the `serializeShadowRoot` variable to the file if the hydrateModule is provided.\n   */\n  if (hydrateModule) {\n    sourceFile.addVariableStatement({\n      isExported: true,\n      declarationKind: VariableDeclarationKind.Const,\n      declarations: [\n        {\n          name: 'serializeShadowRoot',\n          type: 'SerializeShadowRootOptions',\n          initializer: serializeShadowRoot\n            ? JSON.stringify(serializeShadowRoot)\n            : '{ default: \"declarative-shadow-dom\" }',\n        },\n      ],\n    });\n  }\n\n  for (const component of components) {\n    const tagName = component.tagName;\n    const reactTagName = kebabToPascalCase(tagName);\n    const componentElement = `${reactTagName}Element`;\n    const componentCustomEvent = `${reactTagName}CustomEvent`;\n\n    sourceFile.addImportDeclaration({\n      moduleSpecifier: `${stencilPackageName}/${customElementsDir}/${tagName}.js`,\n      namedImports: [\n        {\n          name: reactTagName,\n          alias: componentElement,\n        },\n        {\n          name: 'defineCustomElement',\n          alias: `define${reactTagName}`,\n        },\n      ],\n    });\n\n    const publicEvents = (component.events || []).filter((e) => e.internal === false);\n    const events: ReactEvent[] = [];\n    const importedEventDetailTypes = new Set<string>();\n    let importedComponentCustomEvent = false;\n\n    for (const event of publicEvents) {\n      /**\n       * Import the referenced types from the component library.\n       * Stencil will automatically re-export type definitions from the components,\n       * if they are used in the component's property or event types.\n       */\n      if (Object.keys(event.complexType.references).length > 0) {\n        for (const referenceKey of Object.keys(event.complexType.references)) {\n          const reference = event.complexType.references[referenceKey];\n          const isGlobalType = reference.location === 'global';\n\n          /**\n           * Global type references should not have an explicit import.\n           * The type should be available globally.\n           */\n          if (!isGlobalType && !importedEventDetailTypes.has(referenceKey)) {\n            importedEventDetailTypes.add(referenceKey);\n            sourceFile.addImportDeclaration({\n              moduleSpecifier: stencilPackageName,\n              namedImports: [\n                {\n                  name: referenceKey,\n                  isTypeOnly: true,\n                },\n              ],\n            });\n          }\n        }\n      }\n\n      /**\n       * Import the CustomEvent type for the web component from the Stencil package.\n       *\n       * For example:\n       * ```\n       * import type { ComponentCustomEvent } from 'my-component-library';\n       * ```\n       */\n      if (!importedComponentCustomEvent) {\n        importedComponentCustomEvent = true;\n        sourceFile.addImportDeclaration({\n          moduleSpecifier: stencilPackageName,\n          namedImports: [\n            {\n              name: componentCustomEvent,\n              isTypeOnly: true,\n            },\n          ],\n        });\n      }\n\n      // Always type events using the Stencil per-component CustomEvent type.\n      events.push({\n        originalName: event.name,\n        name: eventListenerName(event.name),\n        type: `EventName<${componentCustomEvent}<${normalizeTypeString(event.complexType.original)}>>`,\n      });\n    }\n\n    const componentEventNamesType = `${reactTagName}Events`;\n\n    sourceFile.addTypeAlias({\n      isExported: true,\n      name: componentEventNamesType,\n      type: events.length > 0 ? `{ ${events.map((e) => `${e.name}: ${e.type}`).join(',\\n')} }` : 'NonNullable<unknown>',\n    });\n\n    const transformTagParam = transformTag ? ',\\n    transformTag' : '';\n    const clientComponentCall = `/*@__PURE__*/ createComponent<${componentElement}, ${componentEventNamesType}>({\n    tagName: '${tagName}',\n    elementClass: ${componentElement},\n    // @ts-ignore - ignore potential React type mismatches between the Stencil Output Target and your project.\n    react: React,\n    events: {${events.map((e) => `${e.name}: '${e.originalName}'`).join(',\\n')}} as ${componentEventNamesType},\n    defineCustomElement: define${reactTagName}${transformTagParam}\n  })`;\n\n    const getTagTransformerParam = transformTag ? ',\\n    getTagTransformer' : '';\n    const serverComponentCall = `/*@__PURE__*/ createComponent<${componentElement}, ${componentEventNamesType}>({\n    tagName: '${tagName}',\n    properties: {${component.properties\n      /**\n       * Filter out properties that don't have an attribute.\n       * These are properties with complex types and can't be serialized.\n       */\n      .filter((prop) => Boolean(prop.attribute))\n      .map((e) => `${e.name}: '${e.attribute}'`)\n      .join(',\\n')}},\n    hydrateModule: import('${hydrateModule}') as Promise<HydrateModule>,\n    clientModule: clientComponents.${reactTagName} as ReactWebComponent<${componentElement}, ${componentEventNamesType}>,\n    serializeShadowRoot${getTagTransformerParam}\n  })`;\n\n    sourceFile.addVariableStatement({\n      isExported: true,\n      declarationKind: VariableDeclarationKind.Const,\n      // React as never is a hack to by-pass a @types/react issue.\n      declarations: [\n        {\n          name: reactTagName,\n          type: `StencilReactComponent<${componentElement}, ${componentEventNamesType}>`,\n          initializer: hydrateModule ? serverComponentCall : clientComponentCall,\n        },\n      ],\n    });\n  }\n\n  sourceFile.organizeImports();\n  sourceFile.formatText();\n\n  return sourceFile.getFullText();\n};\n","export const createTagTransformer = ({\n  stencilPackageName,\n  customElementsDir,\n}: {\n  stencilPackageName: string;\n  customElementsDir: string;\n}) => {\n  return `/* eslint-disable */\n/* tslint:disable */\nimport { setTagTransformer as clientSetTagTransformer } from '${stencilPackageName}/${customElementsDir}/index.js';\n\nlet tagTransformer: ((tagName: string) => string) | undefined;\n\nexport const setTagTransformer = (transformer: (tagName: string) => string) => {\n  clientSetTagTransformer(transformer);\n  tagTransformer = transformer;\n};\n\nexport const transformTag = (tag: string): string => {\n  return tagTransformer ? tagTransformer(tag) : tag;\n};\n\nexport const getTagTransformer = () => tagTransformer;\n`;\n};\n","import type { ComponentCompilerMeta } from '@stencil/core/internal';\nimport path from 'node:path';\nimport { Project, SourceFile } from 'ts-morph';\nimport { createEsModulesComponentsFile } from './create-es-modules-components-file.js';\nimport { createStencilReactComponents } from './create-stencil-react-components.js';\nimport { createTagTransformer } from './create-tag-transformer.js';\nimport type { RenderToStringOptions } from './runtime/ssr.js';\n\nexport const createComponentWrappers = async ({\n  stencilPackageName,\n  components,\n  outDir,\n  esModules,\n  customElementsDir,\n  excludeComponents,\n  project,\n  hydrateModule,\n  clientModule,\n  excludeServerSideRenderingFor,\n  serializeShadowRoot,\n  transformTag,\n}: {\n  stencilPackageName: string;\n  components: ComponentCompilerMeta[];\n  customElementsDir: string;\n  outDir: string;\n  esModules?: boolean;\n  excludeComponents?: string[];\n  project: Project;\n  hydrateModule?: string;\n  clientModule?: string;\n  excludeServerSideRenderingFor?: string[];\n  serializeShadowRoot?: RenderToStringOptions['serializeShadowRoot'];\n  transformTag?: boolean;\n}) => {\n  const sourceFiles: SourceFile[] = [];\n\n  const filteredComponents = components.filter((c) => {\n    if (c.internal === true) {\n      /**\n       * Skip internal components\n       */\n      return false;\n    }\n    if (excludeComponents?.includes(c.tagName)) {\n      /**\n       * Skip excluded components\n       */\n      return false;\n    }\n\n    return true;\n  });\n\n  if (filteredComponents.length === 0) {\n    return [];\n  }\n\n  const fileContents: Record<string, string> = {};\n\n  /**\n   * create a single file with all components or a separate file for each component\n   * @param components - the components to create the file for\n   * @param filename - the filename of the file to create\n   */\n  function createComponentFile(components: ComponentCompilerMeta[], filename = 'components') {\n    /**\n     * create a single file with all components\n     */\n    const outputPath = path.join(outDir, `${filename}.ts`);\n\n    /**\n     * create a client side component\n     */\n    const stencilReactComponent = createStencilReactComponents({\n      components,\n      stencilPackageName,\n      customElementsDir,\n      transformTag,\n    });\n    fileContents[outputPath] = stencilReactComponent;\n\n    /**\n     * create tag-transformer file (for both client and server)\n     */\n    if (transformTag) {\n      const tagTransformerPath = path.join(outDir, 'tag-transformer.ts');\n      fileContents[tagTransformerPath] = createTagTransformer({ stencilPackageName, customElementsDir });\n    }\n\n    /**\n     * create a server side component\n     */\n    if (hydrateModule) {\n      const outputPath = path.join(outDir, `${filename}.server.ts`);\n      const stencilReactComponent = createStencilReactComponents({\n        components: components.filter(\n          (c) => !excludeServerSideRenderingFor || !excludeServerSideRenderingFor.includes(c.tagName)\n        ),\n        stencilPackageName,\n        customElementsDir,\n        hydrateModule,\n        clientModule,\n        serializeShadowRoot,\n        transformTag,\n      });\n      fileContents[outputPath] = stencilReactComponent;\n    }\n  }\n\n  if (esModules) {\n    /**\n     * create a separate file for each component\n     */\n    for (const component of filteredComponents) {\n      createComponentFile([component], component.tagName);\n    }\n    const componentsSource = await createEsModulesComponentsFile({ components: filteredComponents, project, outDir });\n    sourceFiles.push(componentsSource);\n  } else {\n    createComponentFile(filteredComponents);\n  }\n\n  await Promise.all(\n    Object.entries(fileContents).map(async ([outputPath, content]) => {\n      const sourceFile = project.createSourceFile(outputPath, content, { overwrite: true });\n      await sourceFile.save();\n      sourceFiles.push(sourceFile);\n    })\n  );\n\n  return sourceFiles;\n};\n","import type { ComponentCompilerMeta } from '@stencil/core/internal';\nimport { kebabToPascalCase, normalizeTypeString } from './utils/string-utils.js';\n\ninterface NativeTypesOptions {\n  components: ComponentCompilerMeta[];\n  stencilPackageName: string;\n  excludeComponents?: string[];\n}\n\n/**\n * Converts an event name to a lowercase React 19 event handler prop name.\n * React 19 lowercases the prop name (minus \"on\") to get the event name.\n * So for event \"myFocus\", the handler prop should be \"onmyfocus\".\n */\nconst toLowercaseEventHandler = (eventName: string): string => {\n  return `on${eventName.toLowerCase()}`;\n};\n\n/**\n * Creates a TypeScript declaration file (.d.ts) that provides type definitions\n * for using Stencil web components as native custom elements in React 19+.\n *\n * The generated file augments the `react/jsx-runtime` module to provide proper\n * typing for custom elements when used directly in JSX without wrapper components.\n */\nexport const createNativeTypes = ({\n  components,\n  stencilPackageName,\n  excludeComponents,\n}: NativeTypesOptions): string => {\n  // Filter components\n  const filteredComponents = components.filter((c) => {\n    if (c.internal === true) return false;\n    if (excludeComponents?.includes(c.tagName)) return false;\n    return true;\n  });\n\n  if (filteredComponents.length === 0) {\n    return '';\n  }\n\n  const lines: string[] = [];\n\n  // Add header comment\n  lines.push(`/**\n * This file was automatically generated by the Stencil React Output Target.\n * Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.\n *\n * This file provides TypeScript type definitions for using Stencil web components\n * as native custom elements in React 19+.\n *\n * Usage:\n * Import this file in your React application to get type support for custom elements:\n * \\`\\`\\`tsx\n * import '${stencilPackageName}/react-native-types';\n * \\`\\`\\`\n */\n\n/* eslint-disable */\n/* tslint:disable */\n`);\n\n  // Add the 'import \"react\"' statement to avoid conflicts with standard HTML elements\n  // The @ts-ignore comments prevent errors when this file is processed in a non-React context\n  lines.push(`// @ts-ignore - React types may not be available in all build contexts`);\n  lines.push(`import 'react';`);\n  lines.push(`// @ts-ignore - React types may not be available in all build contexts`);\n  lines.push(`import type { DetailedHTMLProps, HTMLAttributes } from 'react';`);\n\n  // Collect all custom event types that need to be imported\n  const customEventTypes = new Set<string>();\n  const referencedTypes = new Set<string>();\n\n  for (const component of filteredComponents) {\n    const reactTagName = kebabToPascalCase(component.tagName);\n    const publicEvents = (component.events || []).filter((e) => !e.internal);\n\n    if (publicEvents.length > 0) {\n      customEventTypes.add(`${reactTagName}CustomEvent`);\n    }\n\n    // Collect referenced types from events\n    for (const event of publicEvents) {\n      if (event.complexType?.references) {\n        for (const [refKey, refValue] of Object.entries(event.complexType.references)) {\n          if (refValue.location !== 'global') {\n            referencedTypes.add(refKey);\n          }\n        }\n      }\n    }\n\n    // Collect referenced types from properties\n    const publicProperties = (component.properties || []).filter((p) => !p.internal);\n    for (const prop of publicProperties) {\n      if (prop.complexType?.references) {\n        for (const [refKey, refValue] of Object.entries(prop.complexType.references)) {\n          if (refValue.location !== 'global') {\n            referencedTypes.add(refKey);\n          }\n        }\n      }\n    }\n  }\n\n  // Add import for CustomEvent types from the Stencil package\n  const allImports = new Set([...customEventTypes, ...referencedTypes]);\n  if (allImports.size > 0) {\n    lines.push(`import type { ${Array.from(allImports).sort().join(', ')} } from '${stencilPackageName}';`);\n  }\n\n  lines.push('');\n\n  // Generate interface for each component\n  for (const component of filteredComponents) {\n    const tagName = component.tagName;\n    const reactTagName = kebabToPascalCase(tagName);\n    const propsInterfaceName = `${reactTagName}NativeProps`;\n    const componentCustomEvent = `${reactTagName}CustomEvent`;\n\n    const interfaceProperties: string[] = [];\n\n    // Add properties (skip methods, only include props)\n    const publicProperties = (component.properties || []).filter((p) => !p.internal);\n    for (const prop of publicProperties) {\n      const propType = prop.complexType?.original || 'any';\n      const docs = prop.docs?.text ? `  /** ${prop.docs.text.trim()} */\\n` : '';\n      // Use the prop name (or attribute name if different)\n      const propName = prop.name;\n      interfaceProperties.push(`${docs}  '${propName}'?: ${normalizeTypeString(propType)};`);\n    }\n\n    // Add events with lowercase naming\n    const publicEvents = (component.events || []).filter((e) => !e.internal);\n    for (const event of publicEvents) {\n      const eventType = normalizeTypeString(event.complexType?.original || 'void');\n      const docs = event.docs?.text\n        ? `  /** Event: ${event.name} - ${event.docs.text.trim()} */\\n`\n        : `  /** Event: ${event.name} */\\n`;\n      const handlerName = toLowercaseEventHandler(event.name);\n      interfaceProperties.push(`${docs}  '${handlerName}'?: (event: ${componentCustomEvent}<${eventType}>) => void;`);\n    }\n\n    // Generate the props interface\n    if (interfaceProperties.length > 0) {\n      lines.push(`interface ${propsInterfaceName} {`);\n      lines.push(interfaceProperties.join('\\n'));\n      lines.push(`}`);\n    } else {\n      lines.push(`interface ${propsInterfaceName} {}`);\n    }\n    lines.push('');\n  }\n\n  // Generate module augmentation for react/jsx-runtime's JSX namespace\n  // This is used when tsconfig has \"jsx\": \"react-jsx\" (React 17+ automatic runtime)\n  lines.push(`declare module 'react/jsx-runtime' {`);\n  lines.push(`  namespace JSX {`);\n  lines.push(`    interface IntrinsicElements {`);\n\n  for (const component of filteredComponents) {\n    const tagName = component.tagName;\n    const reactTagName = kebabToPascalCase(tagName);\n    const propsInterfaceName = `${reactTagName}NativeProps`;\n    const elementType = `HTML${reactTagName}Element`;\n\n    lines.push(\n      `      '${tagName}': DetailedHTMLProps<HTMLAttributes<${elementType}> & ${propsInterfaceName}, ${elementType}>;`\n    );\n  }\n\n  lines.push(`    }`);\n  lines.push(`  }`);\n  lines.push(`}`);\n  lines.push('');\n\n  return lines.join('\\n');\n};\n","import type { BuildCtx, OutputTargetCustom, OutputTargetDistCustomElements } from '@stencil/core/internal';\nimport path from 'node:path';\nimport { Project } from 'ts-morph';\nimport { createComponentWrappers } from './create-component-wrappers.js';\nimport { createNativeTypes } from './create-native-types.js';\nimport type { RenderToStringOptions } from './runtime/ssr.js';\n\nconst DEFAULT_NATIVE_TYPES_FILENAME = 'react-native-types.d.ts';\n\nexport interface ReactOutputTargetOptions {\n  /**\n   * Specify the output directory or path where the generated React components will be saved.\n   *\n   * This option is required unless `nativeTypesPath` is specified. When only generating\n   * native type definitions for React 19+, this option can be omitted.\n   */\n  outDir?: string;\n  /**\n   * Path to generate a TypeScript declaration file (.d.ts) that provides type definitions\n   * for using Stencil web components as native custom elements in React 19+.\n   *\n   * This can be either:\n   * - A full file path ending in `.d.ts` (e.g., `'dist/types/my-types.d.ts'`) or\n   * - A directory path (e.g., `'dist/types'`), which will generate `react-native-types.d.ts` in that directory\n   *\n   * **Important:** Your component library's `package.json` should include `@types/react` as an\n   * optional peer dependency to ensure proper TypeScript module resolution:\n   * ```json\n   * {\n   *   \"peerDependencies\": { \"@types/react\": \">=18\" },\n   *   \"peerDependenciesMeta\": { \"@types/react\": { \"optional\": true } }\n   * }\n   * ```\n   *\n   * Example usage in your React app:\n   * ```tsx\n   * // Import the generated types (side-effect import)\n   * import 'my-library/react-native-types';\n   *\n   * // use your web components in jsx\n   * ```\n   */\n  nativeTypesPath?: string;\n  /**\n   * Specify the components that should be excluded from the React output target.\n   */\n  excludeComponents?: string[];\n  /**\n   * The package name of the Stencil project.\n   *\n   * This value is automatically detected from the package.json file of the Stencil project.\n   * If the validation fails, you can manually assign the package name.\n   */\n  stencilPackageName?: string;\n  /**\n   * The directory where the custom elements are saved.\n   *\n   * This value is automatically detected from the Stencil configuration file for the dist-custom-elements output target.\n   * If you are working in an environment that uses absolute paths, consider setting this value manually.\n   */\n  customElementsDir?: string;\n  /**\n   * To enable server side rendering, provide the path to the hydrate module, e.g. `my-component/hydrate`.\n   * By default this value is undefined and server side rendering is disabled.\n   */\n  hydrateModule?: string;\n  /**\n   * The name of the package that exports all React wrapped Stencil components for client side rendering.\n   * This options is required when `hydrateModule` is set for server side rendering to work.\n   */\n  clientModule?: string;\n  /**\n   * Specify the components that should be excluded from server side rendering.\n   */\n  excludeServerSideRenderingFor?: string[];\n  /**\n   * If `true`, the output target will generate a separate ES module for each React component wrapper (better for tree-shaking).\n   * @default false\n   */\n  esModules?: boolean;\n  /**\n   * Configure how Stencil serializes the components shadow root.\n   * - If set to `declarative-shadow-dom` the component will be rendered within a Declarative Shadow DOM.\n   * - If set to `scoped` Stencil will render the contents of the shadow root as a `scoped: true` component\n   *   and the shadow DOM will be created during client-side hydration.\n   * - Alternatively you can mix and match the two by providing an object with `declarative-shadow-dom` and `scoped` keys,\n   * the value arrays containing the tag names of the components that should be rendered in that mode.\n   *\n   * Examples:\n   * - `{ 'declarative-shadow-dom': ['my-component-1', 'another-component'], default: 'scoped' }`\n   * Render all components as `scoped` apart from `my-component-1` and `another-component`\n   * -  `{ 'scoped': ['an-option-component'], default: 'declarative-shadow-dom' }`\n   * Render all components within `declarative-shadow-dom` apart from `an-option-component`\n   * - `'scoped'` Render all components as `scoped`\n   * - `false` disables shadow root serialization\n   *\n   * *NOTE* `true` has been deprecated in favor of `declarative-shadow-dom` and `scoped`\n   * @default 'declarative-shadow-dom'\n   */\n  serializeShadowRoot?: RenderToStringOptions['serializeShadowRoot'];\n  /**\n   * Use `transformTag` to enable runtime tag name transformation for your components.\n   * When enabled, the output target will import `transformTag` from your component library\n   * and apply it when rendering components.\n   *\n   * You must export `transformTag` from the root entry of your component library:\n   * ```ts\n   * // src/index.ts\n   * export { transformTag } from '@stencil/core';\n   * ```\n   *\n   * @default false\n   */\n  transformTag?: boolean;\n}\n\nconst PLUGIN_NAME = 'react-output-target';\n\nconst DIST_CUSTOM_ELEMENTS_DEFAULT_DIR = 'dist/components';\nconst DIST_CUSTOM_ELEMENTS = 'dist-custom-elements';\nconst HYDRATE_OUTPUT_TARGET = 'dist-hydrate-script';\n\ninterface ReactOutputTarget extends OutputTargetCustom {\n  __internal_getCustomElementsDir: () => string;\n}\n\n/**\n * Creates an output target for binding Stencil components to be used in a React context\n * @public\n * @param outputTarget the user-defined output target defined in a Stencil configuration file\n * @returns an output target that can be used by the Stencil compiler\n */\nexport const reactOutputTarget = ({\n  outDir,\n  nativeTypesPath,\n  esModules,\n  stencilPackageName,\n  excludeComponents,\n  customElementsDir: customElementsDirOverride,\n  hydrateModule,\n  clientModule,\n  excludeServerSideRenderingFor,\n  serializeShadowRoot,\n  transformTag,\n}: ReactOutputTargetOptions): ReactOutputTarget => {\n  let customElementsDir = DIST_CUSTOM_ELEMENTS_DEFAULT_DIR;\n  return {\n    type: 'custom',\n    name: PLUGIN_NAME,\n    validate(config) {\n      /**\n       * Validate that at least one output is configured.\n       */\n      if (!outDir && !nativeTypesPath) {\n        throw new Error(`The '${PLUGIN_NAME}' requires either 'outDir' or 'nativeTypesPath' to be specified.`);\n      }\n\n      /**\n       * Validate the configuration to ensure that the dist-custom-elements\n       * output target is defined in the Stencil configuration when generating\n       * wrapper components (outDir is set).\n       *\n       * This context is used to detect a customized output path.\n       */\n      if (outDir) {\n        if (customElementsDirOverride) {\n          customElementsDir = customElementsDirOverride;\n        } else {\n          const customElementsOutputTarget = (config.outputTargets || []).find(\n            (o) => o.type === DIST_CUSTOM_ELEMENTS\n          ) as OutputTargetDistCustomElements;\n          if (customElementsOutputTarget == null) {\n            throw new Error(\n              `The '${PLUGIN_NAME}' requires '${DIST_CUSTOM_ELEMENTS}' output target when 'outDir' is specified. Add { type: '${DIST_CUSTOM_ELEMENTS}' }, to the outputTargets config.`\n            );\n          }\n          if (customElementsOutputTarget.dir !== undefined) {\n            /**\n             * If the developer has configured a custom output path for the Stencil components,\n             * we need to use that path when importing the components in the React components.\n             */\n            customElementsDir = customElementsOutputTarget.dir;\n          }\n\n          /**\n           * Validate the configuration for `dist-custom-elements` output target to ensure that\n           * the bundle generates its own runtime. This is important because we need to ensure that\n           * the Stencil runtime has hydration flags set which the default Stencil runtime does not have.\n           */\n          if (customElementsOutputTarget.externalRuntime !== false) {\n            throw new Error(\n              `The '${PLUGIN_NAME}' requires the '${DIST_CUSTOM_ELEMENTS}' output target to have 'externalRuntime: false' set in its configuration.`\n            );\n          }\n        }\n\n        /**\n         * Validate the configuration to ensure that the dist-hydrate-script\n         * output target is defined in the Stencil configuration if the hydrateModule is provided.\n         */\n        if (hydrateModule) {\n          const hydrateOutputTarget = (config.outputTargets || []).find((o) => o.type === HYDRATE_OUTPUT_TARGET);\n          if (hydrateOutputTarget == null) {\n            throw new Error(\n              `The '${PLUGIN_NAME}' requires '${HYDRATE_OUTPUT_TARGET}' output target when the 'hydrateModule' option is set. Add { type: '${HYDRATE_OUTPUT_TARGET}' }, to the outputTargets config.`\n            );\n          }\n\n          if (clientModule == null) {\n            throw new Error(\n              `The '${PLUGIN_NAME}' requires the 'clientModule' option when the 'hydrateModule' option is set. Please provide the clientModule manually to the ${PLUGIN_NAME} output target.`\n            );\n          }\n        }\n      }\n\n      /**\n       * Validate the configuration to detect the package name of the Stencil project.\n       */\n      if (stencilPackageName === undefined) {\n        if (config.sys && config.packageJsonFilePath) {\n          const { name: packageName } = JSON.parse(config.sys.readFileSync(config.packageJsonFilePath, 'utf8'));\n          stencilPackageName = packageName;\n        }\n\n        if (!stencilPackageName) {\n          throw new Error(\n            `Unable to find the package name in the package.json file: ${config.packageJsonFilePath}. Please provide the stencilPackageName manually to the ${PLUGIN_NAME} output target.`\n          );\n        }\n      }\n    },\n    async generator(_config, compilerCtx, buildCtx: BuildCtx) {\n      const timespan = buildCtx.createTimeSpan(`generate ${PLUGIN_NAME} started`, true);\n\n      const components = buildCtx.components;\n\n      // Generate wrapper components if outDir is specified\n      if (outDir) {\n        const project = new Project();\n\n        const sourceFiles = await createComponentWrappers({\n          outDir,\n          components,\n          stencilPackageName: stencilPackageName!,\n          customElementsDir,\n          excludeComponents,\n          esModules: esModules === true,\n          project,\n          hydrateModule,\n          clientModule,\n          excludeServerSideRenderingFor,\n          serializeShadowRoot,\n          transformTag,\n        });\n\n        await Promise.all(\n          sourceFiles.map((sourceFile) => compilerCtx.fs.writeFile(sourceFile.getFilePath(), sourceFile.getFullText()))\n        );\n      }\n\n      // Generate native types if nativeTypesPath is specified\n      if (nativeTypesPath) {\n        const nativeTypesContent = createNativeTypes({\n          components,\n          stencilPackageName: stencilPackageName!,\n          excludeComponents,\n        });\n\n        if (nativeTypesContent) {\n          // If the path doesn't end with .d.ts, treat it as a directory and append the default filename\n          let outputPath = nativeTypesPath.endsWith('.d.ts')\n            ? nativeTypesPath\n            : path.join(nativeTypesPath, DEFAULT_NATIVE_TYPES_FILENAME);\n\n          // Normalize to absolute path if relative\n          if (!path.isAbsolute(outputPath) && _config.rootDir) {\n            outputPath = path.join(_config.rootDir, outputPath);\n          }\n\n          await compilerCtx.fs.writeFile(outputPath, nativeTypesContent);\n        }\n      }\n\n      timespan.finish(`generate ${PLUGIN_NAME} finished`);\n    },\n    __internal_getCustomElementsDir() {\n      return customElementsDir;\n    },\n  };\n};\n"],"names":["kebabToPascalCase","str","segment","kebabToCamelCase","_","letter","slashesToCamelCase","eventListenerName","eventName","slashesConverted","normalizeTypeString","type","createEsModulesComponentsFile","components","project","outDir","tsProject","Project","disableEslint","autogeneratedComment","outFile","path","sourceFile","component","tagName","reactTagName","fileName","createStencilReactComponents","stencilPackageName","customElementsDir","hydrateModule","clientModule","serializeShadowRoot","transformTag","useClientDirective","getTagTransformerImport","createComponentImport","transformTagImport","VariableDeclarationKind","componentElement","componentCustomEvent","publicEvents","e","events","importedEventDetailTypes","importedComponentCustomEvent","event","referenceKey","componentEventNamesType","transformTagParam","clientComponentCall","getTagTransformerParam","serverComponentCall","prop","createTagTransformer","createComponentWrappers","esModules","excludeComponents","excludeServerSideRenderingFor","sourceFiles","filteredComponents","c","fileContents","createComponentFile","filename","outputPath","stencilReactComponent","tagTransformerPath","componentsSource","content","toLowercaseEventHandler","createNativeTypes","lines","customEventTypes","referencedTypes","_a","refKey","refValue","publicProperties","p","_b","allImports","propsInterfaceName","interfaceProperties","propType","_c","docs","_d","propName","eventType","_e","_f","handlerName","elementType","DEFAULT_NATIVE_TYPES_FILENAME","PLUGIN_NAME","DIST_CUSTOM_ELEMENTS_DEFAULT_DIR","DIST_CUSTOM_ELEMENTS","HYDRATE_OUTPUT_TARGET","reactOutputTarget","nativeTypesPath","customElementsDirOverride","config","customElementsOutputTarget","o","packageName","_config","compilerCtx","buildCtx","timespan","nativeTypesContent"],"mappings":"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"}