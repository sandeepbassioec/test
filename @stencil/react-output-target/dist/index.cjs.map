{"version":3,"file":"index.cjs","sources":["../src/utils/string-utils.ts","../src/create-es-modules-components-file.ts","../src/create-stencil-react-components.ts","../src/create-tag-transformer.ts","../src/create-component-wrappers.ts","../src/create-native-types.ts","../src/index.ts"],"sourcesContent":["export const kebabToPascalCase = (str: string) =>\n  str\n    .toLowerCase()\n    .split('-')\n    .map((segment) => segment.charAt(0).toUpperCase() + segment.slice(1))\n    .join('');\n\nexport const kebabToCamelCase = (str: string) => str.replace(/-([_a-z])/g, (_, letter) => letter.toUpperCase());\n\nconst slashesToCamelCase = (str: string) => str.replace(/\\/([a-z])/g, (_, letter) => letter.toUpperCase());\n\nexport const eventListenerName = (eventName: string) => {\n  const slashesConverted = slashesToCamelCase(eventName);\n  return kebabToCamelCase(`on-${slashesConverted}`);\n};\n\n/**\n * Normalizes a type string by removing single-line comments and collapsing whitespace.\n * This is necessary because multiline types with comments would break when collapsed to a single line.\n */\nexport const normalizeTypeString = (type: string) =>\n  type\n    .replace(/\\/\\/.*$/gm, '') // Remove single-line comments\n    .replace(/\\n/g, ' ') // Replace newlines with spaces\n    .replace(/\\s{2,}/g, ' ') // Collapse multiple spaces\n    .trim();\n","import type { ComponentCompilerMeta } from '@stencil/core/internal';\nimport path from 'node:path';\nimport { Project } from 'ts-morph';\nimport { kebabToPascalCase } from './utils/string-utils.js';\n\nexport const createEsModulesComponentsFile = async ({\n  components,\n  project,\n  outDir,\n}: {\n  components: ComponentCompilerMeta[];\n  project?: Project;\n  outDir?: string;\n}) => {\n  const tsProject = project || new Project({ useInMemoryFileSystem: true });\n  const disableEslint = `/* eslint-disable */\\n`;\n  const autogeneratedComment = `/**\n * This file was automatically generated by the Stencil React Output Target.\n * Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.\n */\\n\\n`;\n  const outFile = path.join(outDir || '', 'components.ts');\n  const sourceFile = tsProject.createSourceFile(outFile, autogeneratedComment + disableEslint, {\n    overwrite: true,\n  });\n\n  for (const component of components) {\n    const tagName = component.tagName;\n    const reactTagName = kebabToPascalCase(tagName);\n    const fileName = component.tagName;\n    sourceFile.addExportDeclaration({\n      moduleSpecifier: `./${fileName}.js`,\n      namedExports: [reactTagName],\n    });\n  }\n\n  sourceFile.organizeImports();\n  sourceFile.formatText();\n  await sourceFile.save();\n\n  return sourceFile;\n};\n","import type { ComponentCompilerMeta } from '@stencil/core/internal';\nimport { Project, VariableDeclarationKind } from 'ts-morph';\nimport { eventListenerName, kebabToPascalCase, normalizeTypeString } from './utils/string-utils.js';\nimport type { RenderToStringOptions } from './runtime/ssr.js';\n\ninterface ReactEvent {\n  originalName: string;\n  name: string;\n  type: string;\n}\n\nexport const createStencilReactComponents = ({\n  components,\n  stencilPackageName,\n  customElementsDir,\n  hydrateModule,\n  clientModule,\n  serializeShadowRoot,\n  transformTag,\n}: {\n  components: ComponentCompilerMeta[];\n  stencilPackageName: string;\n  customElementsDir: string;\n  hydrateModule?: string;\n  clientModule?: string;\n  serializeShadowRoot?: RenderToStringOptions['serializeShadowRoot'];\n  transformTag?: boolean;\n}) => {\n  const project = new Project({ useInMemoryFileSystem: true });\n\n  /**\n   * automatically attach the `use client` directive if we are not generating\n   * server side rendering components.\n   */\n  const useClientDirective = !hydrateModule ? `'use client';\\n\\n` : '';\n  const autogeneratedComment = `/**\n * This file was automatically generated by the Stencil React Output Target.\n * Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.\n */\\n\\n`;\n\n  const disableEslint = `/* eslint-disable */\\n`;\n  const getTagTransformerImport = transformTag ? `import { getTagTransformer } from './tag-transformer.js';\\n` : '';\n  const createComponentImport = hydrateModule\n    ? [\n        `// @ts-ignore - ignore potential type issues as the project is importing itself`,\n        `import * as clientComponents from '${clientModule}';`,\n        getTagTransformerImport,\n        `import { createComponent, type SerializeShadowRootOptions, type HydrateModule, type ReactWebComponent, type DynamicFunction } from '@stencil/react-output-target/ssr';`,\n      ]\n        .filter(Boolean)\n        .join('\\n')\n    : `import { createComponent } from '@stencil/react-output-target/runtime';`;\n  // transformTag should be imported from tag-transformer for both client and server\n  const transformTagImport = transformTag ? `import { transformTag } from './tag-transformer.js';\\n` : '';\n  const sourceFile = project.createSourceFile(\n    'component.ts',\n    `${useClientDirective}${autogeneratedComment}${disableEslint}\nimport React from 'react';\n${createComponentImport}\nimport type { EventName, StencilReactComponent } from '@stencil/react-output-target/runtime';\n${transformTagImport}\n  `\n  );\n\n  /**\n   * Add the `serializeShadowRoot` variable to the file if the hydrateModule is provided.\n   */\n  if (hydrateModule) {\n    sourceFile.addVariableStatement({\n      isExported: true,\n      declarationKind: VariableDeclarationKind.Const,\n      declarations: [\n        {\n          name: 'serializeShadowRoot',\n          type: 'SerializeShadowRootOptions',\n          initializer: serializeShadowRoot\n            ? JSON.stringify(serializeShadowRoot)\n            : '{ default: \"declarative-shadow-dom\" }',\n        },\n      ],\n    });\n  }\n\n  for (const component of components) {\n    const tagName = component.tagName;\n    const reactTagName = kebabToPascalCase(tagName);\n    const componentElement = `${reactTagName}Element`;\n    const componentCustomEvent = `${reactTagName}CustomEvent`;\n\n    sourceFile.addImportDeclaration({\n      moduleSpecifier: `${stencilPackageName}/${customElementsDir}/${tagName}.js`,\n      namedImports: [\n        {\n          name: reactTagName,\n          alias: componentElement,\n        },\n        {\n          name: 'defineCustomElement',\n          alias: `define${reactTagName}`,\n        },\n      ],\n    });\n\n    const publicEvents = (component.events || []).filter((e) => e.internal === false);\n    const events: ReactEvent[] = [];\n    const importedEventDetailTypes = new Set<string>();\n    let importedComponentCustomEvent = false;\n\n    for (const event of publicEvents) {\n      /**\n       * Import the referenced types from the component library.\n       * Stencil will automatically re-export type definitions from the components,\n       * if they are used in the component's property or event types.\n       */\n      if (Object.keys(event.complexType.references).length > 0) {\n        for (const referenceKey of Object.keys(event.complexType.references)) {\n          const reference = event.complexType.references[referenceKey];\n          const isGlobalType = reference.location === 'global';\n\n          /**\n           * Global type references should not have an explicit import.\n           * The type should be available globally.\n           */\n          if (!isGlobalType && !importedEventDetailTypes.has(referenceKey)) {\n            importedEventDetailTypes.add(referenceKey);\n            sourceFile.addImportDeclaration({\n              moduleSpecifier: stencilPackageName,\n              namedImports: [\n                {\n                  name: referenceKey,\n                  isTypeOnly: true,\n                },\n              ],\n            });\n          }\n        }\n      }\n\n      /**\n       * Import the CustomEvent type for the web component from the Stencil package.\n       *\n       * For example:\n       * ```\n       * import type { ComponentCustomEvent } from 'my-component-library';\n       * ```\n       */\n      if (!importedComponentCustomEvent) {\n        importedComponentCustomEvent = true;\n        sourceFile.addImportDeclaration({\n          moduleSpecifier: stencilPackageName,\n          namedImports: [\n            {\n              name: componentCustomEvent,\n              isTypeOnly: true,\n            },\n          ],\n        });\n      }\n\n      // Always type events using the Stencil per-component CustomEvent type.\n      events.push({\n        originalName: event.name,\n        name: eventListenerName(event.name),\n        type: `EventName<${componentCustomEvent}<${normalizeTypeString(event.complexType.original)}>>`,\n      });\n    }\n\n    const componentEventNamesType = `${reactTagName}Events`;\n\n    sourceFile.addTypeAlias({\n      isExported: true,\n      name: componentEventNamesType,\n      type: events.length > 0 ? `{ ${events.map((e) => `${e.name}: ${e.type}`).join(',\\n')} }` : 'NonNullable<unknown>',\n    });\n\n    const transformTagParam = transformTag ? ',\\n    transformTag' : '';\n    const clientComponentCall = `/*@__PURE__*/ createComponent<${componentElement}, ${componentEventNamesType}>({\n    tagName: '${tagName}',\n    elementClass: ${componentElement},\n    // @ts-ignore - ignore potential React type mismatches between the Stencil Output Target and your project.\n    react: React,\n    events: {${events.map((e) => `${e.name}: '${e.originalName}'`).join(',\\n')}} as ${componentEventNamesType},\n    defineCustomElement: define${reactTagName}${transformTagParam}\n  })`;\n\n    const getTagTransformerParam = transformTag ? ',\\n    getTagTransformer' : '';\n    const serverComponentCall = `/*@__PURE__*/ createComponent<${componentElement}, ${componentEventNamesType}>({\n    tagName: '${tagName}',\n    properties: {${component.properties\n      /**\n       * Filter out properties that don't have an attribute.\n       * These are properties with complex types and can't be serialized.\n       */\n      .filter((prop) => Boolean(prop.attribute))\n      .map((e) => `${e.name}: '${e.attribute}'`)\n      .join(',\\n')}},\n    hydrateModule: import('${hydrateModule}') as Promise<HydrateModule>,\n    clientModule: clientComponents.${reactTagName} as ReactWebComponent<${componentElement}, ${componentEventNamesType}>,\n    serializeShadowRoot${getTagTransformerParam}\n  })`;\n\n    sourceFile.addVariableStatement({\n      isExported: true,\n      declarationKind: VariableDeclarationKind.Const,\n      // React as never is a hack to by-pass a @types/react issue.\n      declarations: [\n        {\n          name: reactTagName,\n          type: `StencilReactComponent<${componentElement}, ${componentEventNamesType}>`,\n          initializer: hydrateModule ? serverComponentCall : clientComponentCall,\n        },\n      ],\n    });\n  }\n\n  sourceFile.organizeImports();\n  sourceFile.formatText();\n\n  return sourceFile.getFullText();\n};\n","export const createTagTransformer = ({\n  stencilPackageName,\n  customElementsDir,\n}: {\n  stencilPackageName: string;\n  customElementsDir: string;\n}) => {\n  return `/* eslint-disable */\n/* tslint:disable */\nimport { setTagTransformer as clientSetTagTransformer } from '${stencilPackageName}/${customElementsDir}/index.js';\n\nlet tagTransformer: ((tagName: string) => string) | undefined;\n\nexport const setTagTransformer = (transformer: (tagName: string) => string) => {\n  clientSetTagTransformer(transformer);\n  tagTransformer = transformer;\n};\n\nexport const transformTag = (tag: string): string => {\n  return tagTransformer ? tagTransformer(tag) : tag;\n};\n\nexport const getTagTransformer = () => tagTransformer;\n`;\n};\n","import type { ComponentCompilerMeta } from '@stencil/core/internal';\nimport path from 'node:path';\nimport { Project, SourceFile } from 'ts-morph';\nimport { createEsModulesComponentsFile } from './create-es-modules-components-file.js';\nimport { createStencilReactComponents } from './create-stencil-react-components.js';\nimport { createTagTransformer } from './create-tag-transformer.js';\nimport type { RenderToStringOptions } from './runtime/ssr.js';\n\nexport const createComponentWrappers = async ({\n  stencilPackageName,\n  components,\n  outDir,\n  esModules,\n  customElementsDir,\n  excludeComponents,\n  project,\n  hydrateModule,\n  clientModule,\n  excludeServerSideRenderingFor,\n  serializeShadowRoot,\n  transformTag,\n}: {\n  stencilPackageName: string;\n  components: ComponentCompilerMeta[];\n  customElementsDir: string;\n  outDir: string;\n  esModules?: boolean;\n  excludeComponents?: string[];\n  project: Project;\n  hydrateModule?: string;\n  clientModule?: string;\n  excludeServerSideRenderingFor?: string[];\n  serializeShadowRoot?: RenderToStringOptions['serializeShadowRoot'];\n  transformTag?: boolean;\n}) => {\n  const sourceFiles: SourceFile[] = [];\n\n  const filteredComponents = components.filter((c) => {\n    if (c.internal === true) {\n      /**\n       * Skip internal components\n       */\n      return false;\n    }\n    if (excludeComponents?.includes(c.tagName)) {\n      /**\n       * Skip excluded components\n       */\n      return false;\n    }\n\n    return true;\n  });\n\n  if (filteredComponents.length === 0) {\n    return [];\n  }\n\n  const fileContents: Record<string, string> = {};\n\n  /**\n   * create a single file with all components or a separate file for each component\n   * @param components - the components to create the file for\n   * @param filename - the filename of the file to create\n   */\n  function createComponentFile(components: ComponentCompilerMeta[], filename = 'components') {\n    /**\n     * create a single file with all components\n     */\n    const outputPath = path.join(outDir, `${filename}.ts`);\n\n    /**\n     * create a client side component\n     */\n    const stencilReactComponent = createStencilReactComponents({\n      components,\n      stencilPackageName,\n      customElementsDir,\n      transformTag,\n    });\n    fileContents[outputPath] = stencilReactComponent;\n\n    /**\n     * create tag-transformer file (for both client and server)\n     */\n    if (transformTag) {\n      const tagTransformerPath = path.join(outDir, 'tag-transformer.ts');\n      fileContents[tagTransformerPath] = createTagTransformer({ stencilPackageName, customElementsDir });\n    }\n\n    /**\n     * create a server side component\n     */\n    if (hydrateModule) {\n      const outputPath = path.join(outDir, `${filename}.server.ts`);\n      const stencilReactComponent = createStencilReactComponents({\n        components: components.filter(\n          (c) => !excludeServerSideRenderingFor || !excludeServerSideRenderingFor.includes(c.tagName)\n        ),\n        stencilPackageName,\n        customElementsDir,\n        hydrateModule,\n        clientModule,\n        serializeShadowRoot,\n        transformTag,\n      });\n      fileContents[outputPath] = stencilReactComponent;\n    }\n  }\n\n  if (esModules) {\n    /**\n     * create a separate file for each component\n     */\n    for (const component of filteredComponents) {\n      createComponentFile([component], component.tagName);\n    }\n    const componentsSource = await createEsModulesComponentsFile({ components: filteredComponents, project, outDir });\n    sourceFiles.push(componentsSource);\n  } else {\n    createComponentFile(filteredComponents);\n  }\n\n  await Promise.all(\n    Object.entries(fileContents).map(async ([outputPath, content]) => {\n      const sourceFile = project.createSourceFile(outputPath, content, { overwrite: true });\n      await sourceFile.save();\n      sourceFiles.push(sourceFile);\n    })\n  );\n\n  return sourceFiles;\n};\n","import type { ComponentCompilerMeta } from '@stencil/core/internal';\nimport { kebabToPascalCase, normalizeTypeString } from './utils/string-utils.js';\n\ninterface NativeTypesOptions {\n  components: ComponentCompilerMeta[];\n  stencilPackageName: string;\n  excludeComponents?: string[];\n}\n\n/**\n * Converts an event name to a lowercase React 19 event handler prop name.\n * React 19 lowercases the prop name (minus \"on\") to get the event name.\n * So for event \"myFocus\", the handler prop should be \"onmyfocus\".\n */\nconst toLowercaseEventHandler = (eventName: string): string => {\n  return `on${eventName.toLowerCase()}`;\n};\n\n/**\n * Creates a TypeScript declaration file (.d.ts) that provides type definitions\n * for using Stencil web components as native custom elements in React 19+.\n *\n * The generated file augments the `react/jsx-runtime` module to provide proper\n * typing for custom elements when used directly in JSX without wrapper components.\n */\nexport const createNativeTypes = ({\n  components,\n  stencilPackageName,\n  excludeComponents,\n}: NativeTypesOptions): string => {\n  // Filter components\n  const filteredComponents = components.filter((c) => {\n    if (c.internal === true) return false;\n    if (excludeComponents?.includes(c.tagName)) return false;\n    return true;\n  });\n\n  if (filteredComponents.length === 0) {\n    return '';\n  }\n\n  const lines: string[] = [];\n\n  // Add header comment\n  lines.push(`/**\n * This file was automatically generated by the Stencil React Output Target.\n * Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.\n *\n * This file provides TypeScript type definitions for using Stencil web components\n * as native custom elements in React 19+.\n *\n * Usage:\n * Import this file in your React application to get type support for custom elements:\n * \\`\\`\\`tsx\n * import '${stencilPackageName}/react-native-types';\n * \\`\\`\\`\n */\n\n/* eslint-disable */\n/* tslint:disable */\n`);\n\n  // Add the 'import \"react\"' statement to avoid conflicts with standard HTML elements\n  // The @ts-ignore comments prevent errors when this file is processed in a non-React context\n  lines.push(`// @ts-ignore - React types may not be available in all build contexts`);\n  lines.push(`import 'react';`);\n  lines.push(`// @ts-ignore - React types may not be available in all build contexts`);\n  lines.push(`import type { DetailedHTMLProps, HTMLAttributes } from 'react';`);\n\n  // Collect all custom event types that need to be imported\n  const customEventTypes = new Set<string>();\n  const referencedTypes = new Set<string>();\n\n  for (const component of filteredComponents) {\n    const reactTagName = kebabToPascalCase(component.tagName);\n    const publicEvents = (component.events || []).filter((e) => !e.internal);\n\n    if (publicEvents.length > 0) {\n      customEventTypes.add(`${reactTagName}CustomEvent`);\n    }\n\n    // Collect referenced types from events\n    for (const event of publicEvents) {\n      if (event.complexType?.references) {\n        for (const [refKey, refValue] of Object.entries(event.complexType.references)) {\n          if (refValue.location !== 'global') {\n            referencedTypes.add(refKey);\n          }\n        }\n      }\n    }\n\n    // Collect referenced types from properties\n    const publicProperties = (component.properties || []).filter((p) => !p.internal);\n    for (const prop of publicProperties) {\n      if (prop.complexType?.references) {\n        for (const [refKey, refValue] of Object.entries(prop.complexType.references)) {\n          if (refValue.location !== 'global') {\n            referencedTypes.add(refKey);\n          }\n        }\n      }\n    }\n  }\n\n  // Add import for CustomEvent types from the Stencil package\n  const allImports = new Set([...customEventTypes, ...referencedTypes]);\n  if (allImports.size > 0) {\n    lines.push(`import type { ${Array.from(allImports).sort().join(', ')} } from '${stencilPackageName}';`);\n  }\n\n  lines.push('');\n\n  // Generate interface for each component\n  for (const component of filteredComponents) {\n    const tagName = component.tagName;\n    const reactTagName = kebabToPascalCase(tagName);\n    const propsInterfaceName = `${reactTagName}NativeProps`;\n    const componentCustomEvent = `${reactTagName}CustomEvent`;\n\n    const interfaceProperties: string[] = [];\n\n    // Add properties (skip methods, only include props)\n    const publicProperties = (component.properties || []).filter((p) => !p.internal);\n    for (const prop of publicProperties) {\n      const propType = prop.complexType?.original || 'any';\n      const docs = prop.docs?.text ? `  /** ${prop.docs.text.trim()} */\\n` : '';\n      // Use the prop name (or attribute name if different)\n      const propName = prop.name;\n      interfaceProperties.push(`${docs}  '${propName}'?: ${normalizeTypeString(propType)};`);\n    }\n\n    // Add events with lowercase naming\n    const publicEvents = (component.events || []).filter((e) => !e.internal);\n    for (const event of publicEvents) {\n      const eventType = normalizeTypeString(event.complexType?.original || 'void');\n      const docs = event.docs?.text\n        ? `  /** Event: ${event.name} - ${event.docs.text.trim()} */\\n`\n        : `  /** Event: ${event.name} */\\n`;\n      const handlerName = toLowercaseEventHandler(event.name);\n      interfaceProperties.push(`${docs}  '${handlerName}'?: (event: ${componentCustomEvent}<${eventType}>) => void;`);\n    }\n\n    // Generate the props interface\n    if (interfaceProperties.length > 0) {\n      lines.push(`interface ${propsInterfaceName} {`);\n      lines.push(interfaceProperties.join('\\n'));\n      lines.push(`}`);\n    } else {\n      lines.push(`interface ${propsInterfaceName} {}`);\n    }\n    lines.push('');\n  }\n\n  // Generate module augmentation for react/jsx-runtime's JSX namespace\n  // This is used when tsconfig has \"jsx\": \"react-jsx\" (React 17+ automatic runtime)\n  lines.push(`declare module 'react/jsx-runtime' {`);\n  lines.push(`  namespace JSX {`);\n  lines.push(`    interface IntrinsicElements {`);\n\n  for (const component of filteredComponents) {\n    const tagName = component.tagName;\n    const reactTagName = kebabToPascalCase(tagName);\n    const propsInterfaceName = `${reactTagName}NativeProps`;\n    const elementType = `HTML${reactTagName}Element`;\n\n    lines.push(\n      `      '${tagName}': DetailedHTMLProps<HTMLAttributes<${elementType}> & ${propsInterfaceName}, ${elementType}>;`\n    );\n  }\n\n  lines.push(`    }`);\n  lines.push(`  }`);\n  lines.push(`}`);\n  lines.push('');\n\n  return lines.join('\\n');\n};\n","import type { BuildCtx, OutputTargetCustom, OutputTargetDistCustomElements } from '@stencil/core/internal';\nimport path from 'node:path';\nimport { Project } from 'ts-morph';\nimport { createComponentWrappers } from './create-component-wrappers.js';\nimport { createNativeTypes } from './create-native-types.js';\nimport type { RenderToStringOptions } from './runtime/ssr.js';\n\nconst DEFAULT_NATIVE_TYPES_FILENAME = 'react-native-types.d.ts';\n\nexport interface ReactOutputTargetOptions {\n  /**\n   * Specify the output directory or path where the generated React components will be saved.\n   *\n   * This option is required unless `nativeTypesPath` is specified. When only generating\n   * native type definitions for React 19+, this option can be omitted.\n   */\n  outDir?: string;\n  /**\n   * Path to generate a TypeScript declaration file (.d.ts) that provides type definitions\n   * for using Stencil web components as native custom elements in React 19+.\n   *\n   * This can be either:\n   * - A full file path ending in `.d.ts` (e.g., `'dist/types/my-types.d.ts'`) or\n   * - A directory path (e.g., `'dist/types'`), which will generate `react-native-types.d.ts` in that directory\n   *\n   * **Important:** Your component library's `package.json` should include `@types/react` as an\n   * optional peer dependency to ensure proper TypeScript module resolution:\n   * ```json\n   * {\n   *   \"peerDependencies\": { \"@types/react\": \">=18\" },\n   *   \"peerDependenciesMeta\": { \"@types/react\": { \"optional\": true } }\n   * }\n   * ```\n   *\n   * Example usage in your React app:\n   * ```tsx\n   * // Import the generated types (side-effect import)\n   * import 'my-library/react-native-types';\n   *\n   * // use your web components in jsx\n   * ```\n   */\n  nativeTypesPath?: string;\n  /**\n   * Specify the components that should be excluded from the React output target.\n   */\n  excludeComponents?: string[];\n  /**\n   * The package name of the Stencil project.\n   *\n   * This value is automatically detected from the package.json file of the Stencil project.\n   * If the validation fails, you can manually assign the package name.\n   */\n  stencilPackageName?: string;\n  /**\n   * The directory where the custom elements are saved.\n   *\n   * This value is automatically detected from the Stencil configuration file for the dist-custom-elements output target.\n   * If you are working in an environment that uses absolute paths, consider setting this value manually.\n   */\n  customElementsDir?: string;\n  /**\n   * To enable server side rendering, provide the path to the hydrate module, e.g. `my-component/hydrate`.\n   * By default this value is undefined and server side rendering is disabled.\n   */\n  hydrateModule?: string;\n  /**\n   * The name of the package that exports all React wrapped Stencil components for client side rendering.\n   * This options is required when `hydrateModule` is set for server side rendering to work.\n   */\n  clientModule?: string;\n  /**\n   * Specify the components that should be excluded from server side rendering.\n   */\n  excludeServerSideRenderingFor?: string[];\n  /**\n   * If `true`, the output target will generate a separate ES module for each React component wrapper (better for tree-shaking).\n   * @default false\n   */\n  esModules?: boolean;\n  /**\n   * Configure how Stencil serializes the components shadow root.\n   * - If set to `declarative-shadow-dom` the component will be rendered within a Declarative Shadow DOM.\n   * - If set to `scoped` Stencil will render the contents of the shadow root as a `scoped: true` component\n   *   and the shadow DOM will be created during client-side hydration.\n   * - Alternatively you can mix and match the two by providing an object with `declarative-shadow-dom` and `scoped` keys,\n   * the value arrays containing the tag names of the components that should be rendered in that mode.\n   *\n   * Examples:\n   * - `{ 'declarative-shadow-dom': ['my-component-1', 'another-component'], default: 'scoped' }`\n   * Render all components as `scoped` apart from `my-component-1` and `another-component`\n   * -  `{ 'scoped': ['an-option-component'], default: 'declarative-shadow-dom' }`\n   * Render all components within `declarative-shadow-dom` apart from `an-option-component`\n   * - `'scoped'` Render all components as `scoped`\n   * - `false` disables shadow root serialization\n   *\n   * *NOTE* `true` has been deprecated in favor of `declarative-shadow-dom` and `scoped`\n   * @default 'declarative-shadow-dom'\n   */\n  serializeShadowRoot?: RenderToStringOptions['serializeShadowRoot'];\n  /**\n   * Use `transformTag` to enable runtime tag name transformation for your components.\n   * When enabled, the output target will import `transformTag` from your component library\n   * and apply it when rendering components.\n   *\n   * You must export `transformTag` from the root entry of your component library:\n   * ```ts\n   * // src/index.ts\n   * export { transformTag } from '@stencil/core';\n   * ```\n   *\n   * @default false\n   */\n  transformTag?: boolean;\n}\n\nconst PLUGIN_NAME = 'react-output-target';\n\nconst DIST_CUSTOM_ELEMENTS_DEFAULT_DIR = 'dist/components';\nconst DIST_CUSTOM_ELEMENTS = 'dist-custom-elements';\nconst HYDRATE_OUTPUT_TARGET = 'dist-hydrate-script';\n\ninterface ReactOutputTarget extends OutputTargetCustom {\n  __internal_getCustomElementsDir: () => string;\n}\n\n/**\n * Creates an output target for binding Stencil components to be used in a React context\n * @public\n * @param outputTarget the user-defined output target defined in a Stencil configuration file\n * @returns an output target that can be used by the Stencil compiler\n */\nexport const reactOutputTarget = ({\n  outDir,\n  nativeTypesPath,\n  esModules,\n  stencilPackageName,\n  excludeComponents,\n  customElementsDir: customElementsDirOverride,\n  hydrateModule,\n  clientModule,\n  excludeServerSideRenderingFor,\n  serializeShadowRoot,\n  transformTag,\n}: ReactOutputTargetOptions): ReactOutputTarget => {\n  let customElementsDir = DIST_CUSTOM_ELEMENTS_DEFAULT_DIR;\n  return {\n    type: 'custom',\n    name: PLUGIN_NAME,\n    validate(config) {\n      /**\n       * Validate that at least one output is configured.\n       */\n      if (!outDir && !nativeTypesPath) {\n        throw new Error(`The '${PLUGIN_NAME}' requires either 'outDir' or 'nativeTypesPath' to be specified.`);\n      }\n\n      /**\n       * Validate the configuration to ensure that the dist-custom-elements\n       * output target is defined in the Stencil configuration when generating\n       * wrapper components (outDir is set).\n       *\n       * This context is used to detect a customized output path.\n       */\n      if (outDir) {\n        if (customElementsDirOverride) {\n          customElementsDir = customElementsDirOverride;\n        } else {\n          const customElementsOutputTarget = (config.outputTargets || []).find(\n            (o) => o.type === DIST_CUSTOM_ELEMENTS\n          ) as OutputTargetDistCustomElements;\n          if (customElementsOutputTarget == null) {\n            throw new Error(\n              `The '${PLUGIN_NAME}' requires '${DIST_CUSTOM_ELEMENTS}' output target when 'outDir' is specified. Add { type: '${DIST_CUSTOM_ELEMENTS}' }, to the outputTargets config.`\n            );\n          }\n          if (customElementsOutputTarget.dir !== undefined) {\n            /**\n             * If the developer has configured a custom output path for the Stencil components,\n             * we need to use that path when importing the components in the React components.\n             */\n            customElementsDir = customElementsOutputTarget.dir;\n          }\n\n          /**\n           * Validate the configuration for `dist-custom-elements` output target to ensure that\n           * the bundle generates its own runtime. This is important because we need to ensure that\n           * the Stencil runtime has hydration flags set which the default Stencil runtime does not have.\n           */\n          if (customElementsOutputTarget.externalRuntime !== false) {\n            throw new Error(\n              `The '${PLUGIN_NAME}' requires the '${DIST_CUSTOM_ELEMENTS}' output target to have 'externalRuntime: false' set in its configuration.`\n            );\n          }\n        }\n\n        /**\n         * Validate the configuration to ensure that the dist-hydrate-script\n         * output target is defined in the Stencil configuration if the hydrateModule is provided.\n         */\n        if (hydrateModule) {\n          const hydrateOutputTarget = (config.outputTargets || []).find((o) => o.type === HYDRATE_OUTPUT_TARGET);\n          if (hydrateOutputTarget == null) {\n            throw new Error(\n              `The '${PLUGIN_NAME}' requires '${HYDRATE_OUTPUT_TARGET}' output target when the 'hydrateModule' option is set. Add { type: '${HYDRATE_OUTPUT_TARGET}' }, to the outputTargets config.`\n            );\n          }\n\n          if (clientModule == null) {\n            throw new Error(\n              `The '${PLUGIN_NAME}' requires the 'clientModule' option when the 'hydrateModule' option is set. Please provide the clientModule manually to the ${PLUGIN_NAME} output target.`\n            );\n          }\n        }\n      }\n\n      /**\n       * Validate the configuration to detect the package name of the Stencil project.\n       */\n      if (stencilPackageName === undefined) {\n        if (config.sys && config.packageJsonFilePath) {\n          const { name: packageName } = JSON.parse(config.sys.readFileSync(config.packageJsonFilePath, 'utf8'));\n          stencilPackageName = packageName;\n        }\n\n        if (!stencilPackageName) {\n          throw new Error(\n            `Unable to find the package name in the package.json file: ${config.packageJsonFilePath}. Please provide the stencilPackageName manually to the ${PLUGIN_NAME} output target.`\n          );\n        }\n      }\n    },\n    async generator(_config, compilerCtx, buildCtx: BuildCtx) {\n      const timespan = buildCtx.createTimeSpan(`generate ${PLUGIN_NAME} started`, true);\n\n      const components = buildCtx.components;\n\n      // Generate wrapper components if outDir is specified\n      if (outDir) {\n        const project = new Project();\n\n        const sourceFiles = await createComponentWrappers({\n          outDir,\n          components,\n          stencilPackageName: stencilPackageName!,\n          customElementsDir,\n          excludeComponents,\n          esModules: esModules === true,\n          project,\n          hydrateModule,\n          clientModule,\n          excludeServerSideRenderingFor,\n          serializeShadowRoot,\n          transformTag,\n        });\n\n        await Promise.all(\n          sourceFiles.map((sourceFile) => compilerCtx.fs.writeFile(sourceFile.getFilePath(), sourceFile.getFullText()))\n        );\n      }\n\n      // Generate native types if nativeTypesPath is specified\n      if (nativeTypesPath) {\n        const nativeTypesContent = createNativeTypes({\n          components,\n          stencilPackageName: stencilPackageName!,\n          excludeComponents,\n        });\n\n        if (nativeTypesContent) {\n          // If the path doesn't end with .d.ts, treat it as a directory and append the default filename\n          let outputPath = nativeTypesPath.endsWith('.d.ts')\n            ? nativeTypesPath\n            : path.join(nativeTypesPath, DEFAULT_NATIVE_TYPES_FILENAME);\n\n          // Normalize to absolute path if relative\n          if (!path.isAbsolute(outputPath) && _config.rootDir) {\n            outputPath = path.join(_config.rootDir, outputPath);\n          }\n\n          await compilerCtx.fs.writeFile(outputPath, nativeTypesContent);\n        }\n      }\n\n      timespan.finish(`generate ${PLUGIN_NAME} finished`);\n    },\n    __internal_getCustomElementsDir() {\n      return customElementsDir;\n    },\n  };\n};\n"],"names":["kebabToPascalCase","str","segment","kebabToCamelCase","_","letter","slashesToCamelCase","eventListenerName","eventName","slashesConverted","normalizeTypeString","type","createEsModulesComponentsFile","components","project","outDir","tsProject","Project","disableEslint","autogeneratedComment","outFile","path","sourceFile","component","tagName","reactTagName","fileName","createStencilReactComponents","stencilPackageName","customElementsDir","hydrateModule","clientModule","serializeShadowRoot","transformTag","useClientDirective","getTagTransformerImport","createComponentImport","transformTagImport","VariableDeclarationKind","componentElement","componentCustomEvent","publicEvents","e","events","importedEventDetailTypes","importedComponentCustomEvent","event","referenceKey","componentEventNamesType","transformTagParam","clientComponentCall","getTagTransformerParam","serverComponentCall","prop","createTagTransformer","createComponentWrappers","esModules","excludeComponents","excludeServerSideRenderingFor","sourceFiles","filteredComponents","c","fileContents","createComponentFile","filename","outputPath","stencilReactComponent","tagTransformerPath","componentsSource","content","toLowercaseEventHandler","createNativeTypes","lines","customEventTypes","referencedTypes","_a","refKey","refValue","publicProperties","p","_b","allImports","propsInterfaceName","interfaceProperties","propType","_c","docs","_d","propName","eventType","_e","_f","handlerName","elementType","DEFAULT_NATIVE_TYPES_FILENAME","PLUGIN_NAME","DIST_CUSTOM_ELEMENTS_DEFAULT_DIR","DIST_CUSTOM_ELEMENTS","HYDRATE_OUTPUT_TARGET","reactOutputTarget","nativeTypesPath","customElementsDirOverride","config","customElementsOutputTarget","o","packageName","_config","compilerCtx","buildCtx","timespan","nativeTypesContent"],"mappings":"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"}